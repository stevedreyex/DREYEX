ABoss.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "ABoss.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
#include "Attack.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// ABoss: Enemy class													   //
	/////////////////////////////////////////////////////////////////////////////
	ABoss::ABoss()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}

	ABoss::ABoss(int x, int y, Hero *h) : Enemy(x, y, 80000, "ABoss", h, ICE)
	{
		attack_damage = 20;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));		//死掉會掉的道具
		status = WALKING;									//一開始是在走路的狀態
		status_counter = 840;								//用來算是否要換status
		step_size = 2;
	}
	ABoss::~ABoss()
	{
	}
	void ABoss::LoadBitmap()
	{
		boss_blood_bar.loadBloodBar();
		/////掉落道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->load();
		}
		/////怪物走路的動畫
		char *filename1_1[4] = { ".\\bitmaps\\ABossL1.bmp",".\\bitmaps\\ABossL2.bmp",".\\bitmaps\\ABossL3.bmp",".\\bitmaps\\ABossL2.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[4] = { ".\\bitmaps\\ABossR1.bmp",".\\bitmaps\\ABossR2.bmp",".\\bitmaps\\ABossR3.bmp",".\\bitmaps\\ABossR2.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		/////攻擊的動畫
		char *filename2_1[2] = { ".\\bitmaps\\ABoss_attackL1.bmp",".\\bitmaps\\ABoss_attackL2.bmp"};
		for (int i = 0; i < 2; i++)	// 載入動畫
			normalAttackL.AddBitmap(filename2_1[i], RGB(0, 0, 0));
		normalAttackL.SetDelayCount(3);
		char *filename2_2[2] = { ".\\bitmaps\\ABoss_attackR1.bmp",".\\bitmaps\\ABoss_attackR2.bmp"};
		for (int i = 0; i < 2; i++)	// 載入動畫
			normalAttackR.AddBitmap(filename2_2[i], RGB(0, 0, 0));
		normalAttackR.SetDelayCount(3);
		q_attack.loadBitmap();
		for (int i = 0; i < 18; i++) 
		{
			ice_attack[i].loadBitmap();
		}
		/////準備攻擊的動畫
		char *filename3_1[3] = { ".\\bitmaps\\Aboss_PrepareAttackL1.bmp",".\\bitmaps\\Aboss_PrepareAttackL2.bmp",".\\bitmaps\\Aboss_PrepareAttackL2.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫
			prepare_attackL.AddBitmap(filename3_1[i], RGB(0, 0, 0));
		prepare_attackL.SetDelayCount(3);
		char *filename3_2[3] = { ".\\bitmaps\\Aboss_PrepareAttackR1.bmp",".\\bitmaps\\Aboss_PrepareAttackR2.bmp",".\\bitmaps\\Aboss_PrepareAttackR3.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫
			prepare_attackR.AddBitmap(filename3_2[i], RGB(0, 0, 0));
		prepare_attackR.SetDelayCount(3);
		/////回去走路的動畫
		char *filename4_1[3] = { ".\\bitmaps\\Aboss_PrepareAttackL3.bmp",".\\bitmaps\\Aboss_PrepareAttackL2.bmp",".\\bitmaps\\Aboss_PrepareAttackL1.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫
			back_to_walkL.AddBitmap(filename4_1[i], RGB(0, 0, 0));
		back_to_walkL.SetDelayCount(3);
		char *filename4_2[3] = { ".\\bitmaps\\Aboss_PrepareAttackR3.bmp",".\\bitmaps\\Aboss_PrepareAttackR2.bmp",".\\bitmaps\\Aboss_PrepareAttackR1.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫
			back_to_walkR.AddBitmap(filename4_2[i], RGB(0, 0, 0));
		back_to_walkR.SetDelayCount(3);
	}
	void ABoss::OnMove(Maps * m) 
	{
		const int STEP_SIZE = 3;
		if (isAlive())
		{					
			attack();											//每次onMove都會檢查是否要攻擊			
			attack_cool_down -= 1;								//每次onMove都會-1
			status_counter -= 1;								//
			movement(m);
			iceAttackMove(m);
			if (status_counter == 390 || status_counter == 180)
			{
				iceAttack();									//在statuscouter在這兩個數字時會攻擊
			}
		}
		if (!isAlive()) 
		{
			CAudio::Instance()->Stop(AUDIO_ABOSS_PREPARE);		//如果死掉要停止這些聲音
			CAudio::Instance()->Stop(AUDIO_ABOSS_WALK);
			itemsOnMove(m);
		}
	}
	void ABoss::OnShow(Maps *m)
	{
		if (isAlive())
		{
			switch (status)			//switch，在不同狀態有不同的動畫
			{
			case WALKING:
			{
				if (_direction == 0) //如果向左
				{
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					boss_blood_bar.setXY(GetX1() - 100, GetY1() -32);;
					boss_blood_bar.showBloodBar(m, hp);
				}
				if(_direction == 1)	//如果像右
				{
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
					boss_blood_bar.setXY(GetX1() - 100, GetY1() -32);;
					boss_blood_bar.showBloodBar(m, hp);
				}
				break;
			}
			case PREPARE:
			{
				if (_direction == 0)
				{
					prepare_attackL.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					prepare_attackL.OnShow();
					boss_blood_bar.setXY(GetX1() - 100, GetY1() -32);;
					boss_blood_bar.showBloodBar(m, hp);
				}
				if(_direction == 1)
				{
					prepare_attackR.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					prepare_attackR.OnShow();
					boss_blood_bar.setXY(GetX1() - 100, GetY1() - 32);
					boss_blood_bar.showBloodBar(m, hp);
				}
				break;
			}
			case ATTACK:
			{
				if (_direction == 0)
				{
					normalAttackL.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					normalAttackL.OnShow();
					boss_blood_bar.setXY(GetX1() - 100, GetY1() - 32);;
					boss_blood_bar.showBloodBar(m, hp);
				}
				if(_direction == 1)
				{
					normalAttackR.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					normalAttackR.OnShow();
					boss_blood_bar.setXY(GetX1() - 100, GetY1() - 32);;
					boss_blood_bar.showBloodBar(m, hp);
				}
				break;
			}
			case BACK_TO_WALK:
			{
				if (_direction == 0)
				{
					back_to_walkL.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					back_to_walkL.OnShow();
					boss_blood_bar.setXY(GetX1()- 100, GetY1() - 32);;
					boss_blood_bar.showBloodBar(m, hp);
				}
				if (_direction == 1)
				{
					back_to_walkR.SetTopLeft(m->screenX(GetX1() - 100), m->screenY(GetY1()));
					back_to_walkR.OnShow();
					boss_blood_bar.setXY(GetX1(), GetY1() - 32 );;
					boss_blood_bar.showBloodBar(m, hp);
				}
				break;
			}
				break;
			}
			iceAttackShow(m);
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int ABoss::GetX1()
	{
		return _x;
	}
	int ABoss::GetY1()
	{
		return _y;
	}
	int ABoss::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int ABoss::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void ABoss::Initialize() 
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking = isUsingQ = false;
		skillTimes = 0;
		hp = 8000;
		boss_blood_bar.setFullHP(hp);
		status = WALKING;
		status_counter = 840;
		///道具
		for (unsigned i = 0; i < items.size(); i++) {
			items.at(i)->Initialize();
		}
	}
	bool ABoss::intersect(int x1, int x2, int y1, int y2)
	{
		//下面有一些加減運算是因為，稻草人的Bitmap本身比稻草人的身體大太多。
		if (isAlive()) 
		{
			if (x2 >= GetX1()  && x1 <= GetX2() && y2 >= GetY1()  && y1 <= GetY2()) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	void ABoss::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void ABoss::SetMovingUp(bool b)
	{
		isMovingUp = b;
	}
	void ABoss::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void ABoss::SetMovingRight(bool b) {
		isMovingRight = b;
	}
	void ABoss::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void ABoss::movement(Maps *m)
	{
		int x = (GetX1()+ GetX2()) / 2;
		int y = (GetY1() + GetY2()) / 2;
		if (distanceToHero() < 50000) {
			switch (status)						//switch 在不同的狀態有不同的移動方式
			{
			case WALKING:
			{step_size = 3;
			if (x <= hero_on_map->GetX1())
			{
				_direction = 1;
			}
			else {
				_direction = 0;
			}
			walkingLeft.OnMove();
			walkingRight.OnMove();
			if (hero_on_map->GetX1() > x && m->isEmpty(GetX2() + step_size, _y) && m->isEmpty(GetX2() + step_size, GetY2()))
			{
				_x += step_size;
			}
			if (hero_on_map->GetX1() < x && m->isEmpty(_x - step_size, _y) && m->isEmpty(_x - step_size, GetY2()))
			{
				_x -= step_size;
			}
			if (hero_on_map->GetY1() > y && m->isEmpty(_x, GetY2() + step_size) && m->isEmpty(GetX2(), GetY2() + step_size))
			{
				_y += step_size;
			}
			if (hero_on_map->GetY1() < y && m->isEmpty(_x, _y - step_size) && m->isEmpty(GetX2(), _y - step_size)) 
			{
				_y -= step_size;
			}
			if (status_counter <= 540)
			{
				status = PREPARE;
				CAudio::Instance()->Stop(AUDIO_ABOSS_WALK);
				CAudio::Instance()->Play(AUDIO_ABOSS_PREPARE);
			}
			break;}
			case PREPARE:
			{step_size = 0;
			prepare_attackL.OnMove();
			prepare_attackR.OnMove();
			if (status_counter <= 420 && status_counter > 300)
			{
				status = ATTACK;
			}
			attack_target_location_x = x + (hero_on_map->GetX1() - x)*2;
			attack_target_location_y = y + ((hero_on_map->GetY1()) - y)*2;
			if (attack_target_location_x > x) 
			{
				_direction = 1;
			}
			else 
			{
				_direction = 0;
			}
			if (status_counter <= 200)
			{
				status = ATTACK;
			}
			break;}
			case ATTACK:
			{step_size = 15;
			attack_damage = 60;
			normalAttackL.OnMove();
			normalAttackR.OnMove(); 
			if (attack_target_location_x > x && m->isEmpty(GetX2() + step_size, _y) && m->isEmpty(GetX2() + step_size, GetY2()))
			{
				_x += step_size;
			}
			if (attack_target_location_x < x && m->isEmpty(_x - step_size, _y) && m->isEmpty(_x - step_size, GetY2())) 
			{
				_x -= step_size;
			}
			if (attack_target_location_y > y && m->isEmpty(_x, GetY2() + step_size) && m->isEmpty(GetX2(), GetY2() + step_size)) 
			{
				_y += step_size;
			}
			if (attack_target_location_y < y && m->isEmpty(_x, _y - step_size) && m->isEmpty(GetX2(), _y - step_size))
			{
				_y -= step_size;
			}
			if (status_counter <= 300 && status_counter > 200)
			{
				status = PREPARE;
				CAudio::Instance()->Play(AUDIO_ABOSS_PREPARE);
			}
			if (status_counter <= 120)
			{
				status = BACK_TO_WALK;
			}
			break; }
			case BACK_TO_WALK:
			{step_size = 0;
			back_to_walkL.OnMove();
			back_to_walkR.OnMove();
			attack_damage = 20;
			if (status_counter == 0)
			{
				status = WALKING;
				status_counter = 840;
				CAudio::Instance()->Play(AUDIO_ABOSS_WALK, true);
			}
			break;}
		}
		}
	}
	void ABoss::attack()
	{
		if (intersect(hero_on_map->GetX1(), hero_on_map->GetX2(), hero_on_map->GetY1(), hero_on_map->GetY2()) && attack_cool_down <= 0) 
		{
			attack_cool_down = 40;					//如果跟hero位置重疊就會攻擊 40/30秒會攻擊一次
			hero_on_map->offsetHp(attack_damage);	//英雄扣血
		}
	}
	void ABoss::iceAttack()		//開始ice attack的function
	{
		if (!isUsingQ)
		{
			isUsingQ = true;
			q_attack.setXY(_x + 100, _y + 100);
			for (int i = 0; i < 18; i++) 
			{
				ice_attack[i].setXY(_x + 100, _y + 100);
			}
			if (_attribute == FIRE)
			{
				CAudio::Instance()->Play(AUDIO_FIRE);
			}
			if (_attribute == ICE)
			{
				CAudio::Instance()->Play(AUDIO_ICE);
			}
			if (_attribute == PLANT)
			{
				CAudio::Instance()->Play(AUDIO_GRASSBALL);
			}
			q_attack.setAttackIsFlying(true);
			for (int i = 0; i < 18; i++) 
			{
				ice_attack[i].setAttackIsFlying(true);
				ice_attack[i].setStepSize((int)(sin(i * 20.0 * 3.14159 / 180.0) * 10), (int)(cos(i * 20 * 3.14159 / 180.0) * 10));
			}
		}
	}
	void ABoss::iceAttackMove(Maps *m) //call attack的onMove 並檢查是否有碰到hero
	{
		if (isUsingQ) 
		{
			q_attack.OnMove(m);
			for (int i = 0; i < 18; i++)
			{
				ice_attack[i].OnMove(m);
				if (hero_on_map->intercect(ice_attack[i].getX1(), ice_attack[i].getX2(), ice_attack[i].getY1(), ice_attack[i].getY2()))
				{
					hero_on_map->offsetHp(attack_damage);
				}
			}
		}
		q_attack.setAttackName(ICE_BALL);
		for (int i = 0; i < 18; i++)
		{
			ice_attack[i].setAttackName(ICE_BALL);
		}
		if (!isUsingQ)
		{
			q_attack.resetAnimation(ICE_BALL);
			for (int i = 0; i < 18; i++)
			{
				ice_attack[i].resetAnimation(ICE_BALL);
			}
		}
	}
	void ABoss::iceAttackShow(Maps * m)					//ice attack的onShow
	{
		if (isUsingQ)
		{
			q_attack.OnShow(m);
			for (int i = 0; i < 18; i++) 
			{
				ice_attack[i].OnShow(m);
			}
			skillTimes += 1;							//+1代表跑了1/30秒
			if (skillTimes > 80) 
			{						//預計讓他飛80/30秒
				isUsingQ = false;
				q_attack.setAttackIsFlying(false);
				for (int i = 0; i < 18; i++)
				{
					ice_attack[i].setAttackIsFlying(false);
				}
				skillTimes = 0;							//跑完整個技能把skillTime設回為0
			}
		}
	}
}

ABoss.h
#ifndef ABOSS_H
#define ABOSS_H
#include "Maps.h"
#include "Character.h"
#include "BossBloodBar.h"
#include "Enemy.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個敵人 												   //
	// 他是boss	 															   //
	/////////////////////////////////////////////////////////////////////////////
	class ABoss :public Enemy
	{
	public:
		ABoss();						//建構子，傳給Character角色名稱
		ABoss(int x, int y, Hero *h);	//建構子，設定角色初始位置給Character()，方便vector一次建立
		~ABoss();
		void LoadBitmap();					//加載敵人Bitmap
		void OnShow(Maps *m) override;		//顯示敵人於畫面上
		void OnMove(Maps *m);				//敵人移動
		int GetX1();						//回傳最左側X值
		int GetY1();						//回傳最上側Y值
		int GetX2();						//回傳最右側X值
		int GetY2();						//回傳最下側Y值
		void Initialize()override;			//初始化
		bool intersect(int x1, int x2, int y1, int y2) override;
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);		//  設定是否往下左右移動
		void SetMovingUp(bool b);		//
		void SetMovingLeft(bool b);		//
		void SetMovingRight(bool b);	//
		void SetXY(int x, int y);		//
		void movement(Maps *m);			//決定角色移動的方式
		//用來攻擊的
		void attack();					//用來判定是否要攻擊//
		void iceAttack();				//判定是否要用冰的技能攻擊
		void iceAttackMove(Maps *m);	//ice_attack的onMove
		void iceAttackShow(Maps *m);	//ice_attack的onShow
	private:
		BossBloodBar boss_blood_bar;	//boss的血條
		CAnimation walkingLeft;			//向左右走的動畫
		CAnimation walkingRight;
		CAnimation normalAttackL;		//向左右攻擊的動畫
		CAnimation normalAttackR;
		CAnimation prepare_attackL;		//準備攻擊的動畫
		CAnimation prepare_attackR;
		CAnimation back_to_walkL;		//準備回到走路狀態的動畫
		CAnimation back_to_walkR;
		enum status {					//boss有的不同狀態，共有四種狀態			
			WALKING,
			PREPARE,
			ATTACK,
			BACK_TO_WALK
		};
		int status;						//boss的狀態
		int step_size;					//每次移動的速度
		int attack_damage;				//攻擊力
		bool isMovingRight;				//是否上下左右走
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;				//是否在攻擊
		int attack_cool_down;			//攻擊的冷卻時間
		int status_counter;				
		int move_or_not;				//是否有在移動
		int time_bump_into_sth;
		int attack_target_location_x, attack_target_location_y;  //要攻擊的標位置
		Attack q_attack;				
		Attack ice_attack[18];			//攻擊時丟的東西
		int skillTimes;					//用來算攻擊要飛多遠
		bool isUsingQ;
	};
}
#endif 
Arrow.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "Arrow.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// Arrow: Item class													   //
	/////////////////////////////////////////////////////////////////////////////
	Arrow::Arrow(int x, int y)
	{
		_arrowX = x;
		_arrowY = y;
		fly_direction = 0;
		_attackIsFlying = false;
	}
	Arrow::Arrow()
	{
		_arrowX = 280;
		_arrowY = 280;
		fly_direction = 0;
		_attackIsFlying = false;
	}
	void Arrow::loadBitmap()
	{
		arrowLeft.LoadBitmap(".\\bitmaps\\arrowLeft.bmp", RGB(0, 0, 0));
		arrowRight.LoadBitmap(".\\bitmaps\\arrowRight.bmp", RGB(0, 0, 0));
		arrowUp.LoadBitmap(".\\bitmaps\\arrowUp.bmp", RGB(0, 0, 0));
		arrowDown.LoadBitmap(".\\bitmaps\\arrowDown.bmp", RGB(0, 0, 0));
	}
	void Arrow::OnMove(Maps * m)
	{
		if (m->isEmpty(_arrowX, _arrowY)) 
		{	//如果下個位置是empty就可以繼續飛
			if (fly_direction == 0 && m->isEmpty(_arrowX, _arrowY))
				_arrowX -= 8;
			if (fly_direction == 1 && m->isEmpty(_arrowX + arrowRight.Width(), _arrowY))
				_arrowX += 8;
			if (fly_direction == 2 && m->isEmpty(_arrowX, _arrowY))
				_arrowY -= 8;
			if (fly_direction == 3 && m->isEmpty(_arrowX, _arrowY + arrowDown.Height()))
				_arrowY += 8;
		}
	}
	void Arrow::OnShow(Maps * m)
	{
		if (fly_direction == 0) 
		{
			arrowLeft.SetTopLeft(m->screenX(_arrowX), m->screenY(_arrowY));
			arrowLeft.ShowBitmap();
		}
		if (fly_direction == 1)
		{
			arrowRight.SetTopLeft(m->screenX(_arrowX), m->screenY(_arrowY));
			arrowRight.ShowBitmap();
		}
		if (fly_direction == 2) 
		{
			arrowUp.SetTopLeft(m->screenX(_arrowX), m->screenY(_arrowY));
			arrowUp.ShowBitmap();
		}
		if (fly_direction == 3) 
		{
			arrowDown.SetTopLeft(m->screenX(_arrowX), m->screenY(_arrowY));
			arrowDown.ShowBitmap();
		}
	}
	void Arrow::setArrowXY(int x, int y)
	{
		_arrowX = x;
		_arrowY = y;
	}
	void Arrow::setDirection(int direction)
	{
		fly_direction = direction;
	}
	void Arrow::setAttackIsFlying(bool b)
	{
		_attackIsFlying = b;
	}
	int Arrow::getX1()
	{
		return _arrowX;
	}
	int Arrow::getX2()
	{
		if (fly_direction == 0)						
		{
			return arrowLeft.Width() + _arrowX;
		}
		if (fly_direction == 1)
		{
			return arrowRight.Width() + _arrowX;
		}
		if (fly_direction == 2)
		{
			return arrowUp.Width() + _arrowX;
		}
		else
		{
			return arrowDown.Width() + _arrowX;
		}
	}
	int Arrow::getY1()
	{
		return _arrowY;
	}
	int Arrow::getY2()
	{
		if (fly_direction == 0)
		{
			return arrowLeft.Height() + _arrowY;
		}
		if (fly_direction == 1)
		{
			return arrowRight.Height() + _arrowY;
		}
		if (fly_direction == 2)
		{
			return arrowUp.Height() + _arrowY;
		}
		else
		{
			return arrowDown.Height() + _arrowY;
		}
	}
}

Arrow.h
#ifndef ARROW_H
#define ARROW_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個敵人												   //
	// 他是哥布林的專屬武器     											   //
	/////////////////////////////////////////////////////////////////////////////
	class Arrow{
	public:
		Arrow(int x, int y);
		Arrow();
		void loadBitmap();
		void OnMove(Maps *m);
		void OnShow(Maps *m);
		void setArrowXY(int x, int y);
		void setDirection(int direction);					//設定方向
		void setAttackIsFlying(bool b);						//設定始飛到一半
		int getX1();									
		int getX2();
		int getY1();
		int getY2();
	private:
		CMovingBitmap arrowLeft;							//arrow向上下左右的圖
		CMovingBitmap arrowRight;
		CMovingBitmap arrowUp;
		CMovingBitmap arrowDown;
		int _arrowX, _arrowY;								//arrow的座標
		int fly_direction;									//0=left, 1=right
		bool _attackIsFlying;
	};
}

#endif // !Scarecrow_H
Attack.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Attack.h"
namespace game_framework {
	Attack::Attack(int x, int y)
	{
		_x = x;
		_y = y;
		step_size_x = 0;
		step_size_y = 0;
		_attribute = FIRE;
		_direction = 0;
		_attackIsFlying = false;
		flame_status = 0;
	}
	Attack::Attack()
	{
		_x = 280;
		_y = 280;
		step_size_x = 0;
		step_size_y = 0;
		_attribute = FIRE;
		_attack_name = FIRE_BALL;
		_direction = 0;
		flame_status = 0;
		_attackIsFlying = false;
	}
	void Attack::loadBitmap()
	{
		fire_attack.LoadBitmap(IDB_FIREATTACK, RGB(0, 0, 0));
		ice_attack.LoadBitmap(IDB_ATTACK1, RGB(0, 0, 0));
		plant_attack.LoadBitmap(IDB_ATTACKPLANT, RGB(0, 0, 0));
		//向左火焰動畫
		char *filename1_1[6] = { ".\\bitmaps\\flameL1.bmp",".\\bitmaps\\flameL2.bmp",".\\bitmaps\\flameL3.bmp",".\\bitmaps\\flameL4.bmp", ".\\bitmaps\\flameL5.bmp", ".\\bitmaps\\flameL6.bmp" };
		for (int i = 0; i < 6; i++)	// 載入動畫(由6張圖形構成)
			flame_L1.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		flame_L1.SetDelayCount(1);
		char *filename1_2[4] = { ".\\bitmaps\\flameL7.bmp",".\\bitmaps\\flameL8.bmp",".\\bitmaps\\flameL9.bmp",".\\bitmaps\\flameL8.bmp"};
		for (int i = 0; i < 4; i++)	// 載入動畫(由4張圖形構成)
			flame_L2.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		flame_L2.SetDelayCount(2);
		//向右火焰動畫
		char *filename2_1[6] = { ".\\bitmaps\\flameR1.bmp",".\\bitmaps\\flameR2.bmp",".\\bitmaps\\flameR3.bmp",".\\bitmaps\\flameR4.bmp", ".\\bitmaps\\flameR5.bmp", ".\\bitmaps\\flameR6.bmp" };
		for (int i = 0; i < 6; i++)	// 載入動畫(由6張圖形構成)
			flame_R1.AddBitmap(filename2_1[i], RGB(0, 0, 0));
		flame_R1.SetDelayCount(1);
		char *filename2_2[4] = { ".\\bitmaps\\flameR7.bmp",".\\bitmaps\\flameR8.bmp",".\\bitmaps\\flameR9.bmp",".\\bitmaps\\flameR8.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由4張圖形構成)
			flame_R2.AddBitmap(filename2_2[i], RGB(0, 0, 0));
		flame_R2.SetDelayCount(2);
		//冰球動畫
		char *filename_ice_ball[3] = { ".\\bitmaps\\ice_attack1.bmp",".\\bitmaps\\ice_attack2.bmp",".\\bitmaps\\ice_attack3.bmp"};
		for (int i = 0; i < 3; i++)	// 載入動畫(由3張圖形構成)
			ice_ball.AddBitmap(filename_ice_ball[i], RGB(0, 0, 0));
		ice_ball.SetDelayCount(3);
		//火球動畫
		char *filename_fire_ball[3] = { ".\\bitmaps\\FireAttack.bmp",".\\bitmaps\\FireAttack2.bmp",".\\bitmaps\\FireAttack3.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫(由3張圖形構成)
			fire_ball.AddBitmap(filename_fire_ball[i], RGB(0, 0, 0));
		fire_ball.SetDelayCount(3);
		//草球動畫
		char *filename_plant_ball[3] = { ".\\bitmaps\\PlantAttack1.bmp",".\\bitmaps\\PlantAttack2.bmp",".\\bitmaps\\PlantAttack3.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫(由3張圖形構成)
			grass_ball.AddBitmap(filename_plant_ball[i], RGB(0, 0, 0));
		grass_ball.SetDelayCount(8);
		//草龍捲風動畫
		char *filename_plant_tornado[12] = { ".\\bitmaps\\tornado1.bmp",".\\bitmaps\\tornado2.bmp",".\\bitmaps\\tornado3.bmp", ".\\bitmaps\\tornado4.bmp", ".\\bitmaps\\tornado5.bmp", ".\\bitmaps\\tornado6.bmp", ".\\bitmaps\\tornado7.bmp", ".\\bitmaps\\tornado8.bmp", ".\\bitmaps\\tornado9.bmp", ".\\bitmaps\\tornado10.bmp", ".\\bitmaps\\tornado11.bmp", ".\\bitmaps\\tornado12.bmp" };
		for (int i = 0; i < 12; i++)	// 載入動畫(由12張圖形構成)
			tornado.AddBitmap(filename_plant_tornado[i], RGB(255, 255, 255));
		tornado.SetDelayCount(1);
	}
	void Attack::OnMove(Maps * m)
	{
		if (_attack_name == FIRE_FLAME)					//看attack_name是什麼決定onMove執行哪裡
		{
			if (_direction == 0)						//如果方向是左邊
			{
				if (flame_status == 0)
					flame_L1.OnMove();
					if (flame_L1.IsFinalBitmap())
					{
						flame_status = 1;
						flame_L2.OnMove();
					}
			}
			else
			{
				if (flame_status == 0)
					flame_R1.OnMove();
					if (flame_R1.IsFinalBitmap())
					{
						flame_status = 1;
						flame_R2.OnMove();
					}
			}
		}
		else
		{
			if (m->isEmpty(_x, _y)) 
			{
				_x += step_size_x;
				_y += step_size_y;
			}
		}
		if (_attack_name == ICE_BALL) 
		{
			ice_ball.OnMove();
		}
		if (_attack_name == FIRE_BALL)
		{
			fire_ball.OnMove();
		}
		if (_attack_name == GRASS_BALL)
		{
			grass_ball.OnMove();
		}
		if (_attack_name == GRASS_TORNADO) {
			tornado.OnMove();

		}
	}
	void Attack::OnShow(Maps * m)
	{																				//看attack_name決定onShow執行哪裡
		if (_attack_name == FIRE_FLAME)
		{
			if (_direction == 0 && m->isEmpty(_x, _y))
			{
				if (flame_status == 0)
				{
					flame_L1.SetTopLeft(m->screenX(_x) - 192, m->screenY(_y));
					flame_L1.OnShow();
				}
				else
				{
					flame_L2.SetTopLeft(m->screenX(_x) - 192, m->screenY(_y));
					flame_L2.OnShow();
				}
			}
			if (_direction == 1 && m->isEmpty(_x, _y))
			{
				if (flame_status == 0)
				{
					flame_R1.SetTopLeft(m->screenX(_x) + 64, m->screenY(_y));
					flame_R1.OnShow();
				}
				else
				{
					flame_R2.SetTopLeft(m->screenX(_x) + 64, m->screenY(_y));
					flame_R2.OnShow();

				}
			}
		}
		if (_attack_name == FIRE_BALL)
		{
			if (m->isEmpty(_x, _y)) 
			{
				fire_ball.SetTopLeft(m->screenX(_x), m->screenY(_y));
				fire_ball.OnShow();
			}
		}
		if (_attack_name == ICE_BALL)
		{
			if (m->isEmpty(_x, _y))
			{
				ice_ball.SetTopLeft(m->screenX(_x), m->screenY(_y));
				ice_ball.OnShow();
			}
		}
		if (_attack_name == GRASS_BALL) 
		{
			if (m->isEmpty(_x, _y))
			{
				grass_ball.SetTopLeft(m->screenX(_x), m->screenY(_y));
				grass_ball.OnShow();
			}
		}
		if (_attack_name == GRASS_TORNADO) 
		{
			if (m->isEmpty(_x, _y)) 
			{
				tornado.SetTopLeft(m->screenX(_x), m->screenY(_y));
				tornado.OnShow();
			}
		}
	}
	void Attack::setAttribute(ELEMENT_ATTRIBUTE attribute)
	{
		_attribute = attribute;
	}
	void Attack::setAttackName(ATTACK_NAME name)				//設定attack_name
	{
		_attack_name = name;
	}
	void Attack::setXY(int x, int y)							//設定xy座標
	{
		if (_attack_name == FIRE_FLAME)
		{
			_x = x;
			_y = y;
		}
		else {
			if (!_attackIsFlying)
			{
				_x = x;
				_y = y;
			}
		}
	}
	void Attack::setDirection(int direction)
	{
		_direction = direction;
	}
	void Attack::setAttackIsFlying(bool b)
	{
		_attackIsFlying = b;
	}
	void Attack::setStepSize(int x, int y)					//設每次onMove x y 加減
	{
		step_size_x = x;
		step_size_y = y;
	}
	void Attack::resetAnimation(ATTACK_NAME atk)			//reset animation
	{
		if (atk == FIRE_FLAME)
		{
			flame_L1.Reset();
			flame_L2.Reset();
			flame_R1.Reset();
			flame_R1.Reset();
			flame_status = 0;
		}
		if (atk == FIRE_BALL) 
		{
			fire_ball.Reset();
		}
		if (atk == GRASS_BALL)
		{
			grass_ball.Reset();
		}
		if (atk == ICE_BALL) 
		{
			ice_ball.Reset();
		}
		if (atk == GRASS_TORNADO)
		{
			tornado.Reset();
		}
	}
	int Attack::getX1()
	{
		if (_attack_name == FIRE_FLAME)
		{
			if (_direction == 0)
			{
				return _x - 192;
			}
			if (_direction == 1)
			{
				return _x + 64;
			}
		}
		return _x;
	}
	int Attack::getX2()						// x2 = x1 + 圖片寬度
	{
		if (_attack_name == FIRE_BALL) 
		{
			return _x + fire_ball.Width();
		}
		if (_attack_name == ICE_BALL)
		{
			return _x + ice_ball.Width();
		}
		if (_attack_name == GRASS_BALL)
		{
			return _x + grass_ball.Width();
		}
		if (_attack_name == FIRE_FLAME) 
		{
			if (_direction == 0)
			{
				return getX1() + flame_L2.Width();
			}
			if (_direction == 1)
			{
				return getX1() + flame_R2.Width();
			}
		}
		if (_attack_name == GRASS_TORNADO) 
		{
			return _x + tornado.Width();
		}
		return _x;
	}
	int Attack::getY1()
	{
		return _y;
	}
	int Attack::getY2()							//y2 = y1 + 圖片高度
	{
		if (_attack_name == FIRE_BALL) 
		{
			return _y + fire_ball.Height();
		}
		if (_attack_name == ICE_BALL) 
		{
			return _y + ice_ball.Height();
		}
		if (_attack_name == GRASS_BALL)
		{
			return _y + grass_ball.Height();
		}
		if (_attack_name == FIRE_FLAME) 
		{
			if (_direction == 0)
			{
				return getY1() + flame_L2.Height();
			}
			if (_direction == 1)
			{
				return getY1() + flame_R2.Height();
			}
		}
		if (_attack_name == GRASS_TORNADO)
		{
			return getY1() + tornado.Height();
		}
		return _y;
	}
}

Attack.h
#ifndef __ATTACK_H
#define __ATTACK_H
#include "Maps.h"
#include "Character.h"
#include "Util.h"
<<<<<<< HEAD
namespace game_framework {
=======
namespace game_framework 
{
>>>>>>> b21484bf4faa30161cb87177111bbcf0ee7ce529
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供各種攻擊招式											   //
	/////////////////////////////////////////////////////////////////////////////
	class Attack 
	{
	public:
		Attack(int x, int y);
		Attack();
		void loadBitmap();
		void OnMove(Maps *m);
		void OnShow(Maps *m);
		void setAttribute(ELEMENT_ATTRIBUTE attribute); //設定攻擊屬性
		void setAttackName(ATTACK_NAME name);			//設定攻擊名稱
		void setXY(int x, int y);
		void setDirection(int direction);				//設定方向
		void setAttackIsFlying(bool b);					//設定attackIsFlying
		void setStepSize(int x, int y);					//設定每次onMove移動的座標大小
		void resetAnimation(ATTACK_NAME atk);			//reset動畫
		int getX1();
		int getX2();
		int getY1();
		int getY2();
	private:
		CMovingBitmap fire_attack;
		CAnimation flame_L1;
		CAnimation flame_L2;
		CAnimation flame_R1;
		CAnimation flame_R2;
		CAnimation ice_ball;
		CAnimation fire_ball;
		CAnimation grass_ball;
		CAnimation tornado;
		CMovingBitmap fire_attack_boom;
		CMovingBitmap ice_attack;
		CMovingBitmap plant_attack;
		bool flame_status;
		int _x, _y;
		int step_size_x, step_size_y;					//每次onMove要移動的座標
		int _direction;									//0=left, 1=right
		ELEMENT_ATTRIBUTE _attribute;
		ATTACK_NAME	_attack_name;						//攻擊的種類從這裡Call
		bool _attackIsFlying;							//攻擊是否正在飛
	};
}
#endif 
BloodBar.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "BloodBar.h"
namespace game_framework 
{
	BloodBar::BloodBar()
	{
		_x = 0;
		_y = 0;
		full_hp = 0;
	}
	void BloodBar::setFullHP(int n) 
	{
		full_hp = n;
	}
	void BloodBar::setXY(int x, int y) 
	{
		_x = x;
		_y = y;
	}
	int BloodBar::getFullHP()
	{
		return (int)full_hp;
	}
	void BloodBar::loadBloodBar() 
	{
		blood_bar[0].LoadBitmap(IDB_BLOODALMOSTDIE, RGB(0, 0, 0));
		blood_bar[1].LoadBitmap(IDB_BLOOD2OVER10, RGB(0, 0, 0));
		blood_bar[2].LoadBitmap(IDB_BLOOD1OF4, RGB(0, 0, 0));
		blood_bar[3].LoadBitmap(IDB_BLOOD3OVER10, RGB(0, 0, 0));
		blood_bar[4].LoadBitmap(IDB_BLOOD4OVER10, RGB(0, 0, 0));
		blood_bar[5].LoadBitmap(IDB_BLOOD2OF4, RGB(0, 0, 0));
		blood_bar[6].LoadBitmap(IDB_BLOOD6OVER10, RGB(0, 0, 0));
		blood_bar[7].LoadBitmap(IDB_BLOOD7OVER10, RGB(0, 0, 0));
		blood_bar[8].LoadBitmap(IDB_BLOOD3OF4, RGB(0, 0, 0));
		blood_bar[9].LoadBitmap(IDB_BLOOD8OVER10, RGB(0, 0, 0));
		blood_bar[10].LoadBitmap(IDB_BLOODLITTLEDAMAGED, RGB(0, 0, 0));
		blood_bar[11].LoadBitmap(IDB_BLOODFULL, RGB(0, 0, 0));
	}
	void BloodBar::showBloodBar(Maps *m1, int hp) 
	{ //  現在血量/滿血血量  的比例 決定血條多長 顯示哪個血條bitmap
		if (hp > full_hp)
		{
			setFullHP(hp);
		}
		double proportion = hp / full_hp;
		if (proportion < 1.0 / 9)
		{
			blood_bar[0].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[0].ShowBitmap();
		}
		else if (proportion < 2.0 / 10)
		{
			blood_bar[1].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[1].ShowBitmap();
		}
		else if (proportion < 1.0 / 4)
		{
			blood_bar[2].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[2].ShowBitmap();
		}
		else if (proportion < 3.0/10)
		{
			blood_bar[3].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[3].ShowBitmap();
		}
		else if (proportion < 4.0/10)
		{
			blood_bar[4].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[4].ShowBitmap();
		}
		else if (proportion < 5.0 / 10)
		{
			blood_bar[5].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[5].ShowBitmap();
		}
		else if (proportion < 6.0 / 10)
		{
			blood_bar[6].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[6].ShowBitmap();
		}
		else if (proportion < 7.0 / 10) 
		{
			blood_bar[7].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[7].ShowBitmap();
		}
		else if (proportion < 3.0 / 4) 
		{
			blood_bar[8].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[8].ShowBitmap();
		}
		else if (proportion < 8.0 / 10)
		{
			blood_bar[9].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[9].ShowBitmap();
		}
		else if (proportion < 9.0 / 10) 
		{
			blood_bar[10].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[10].ShowBitmap();
		}
		else 
		{
			blood_bar[11].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[11].ShowBitmap();
		}
	}
}

BloodBar.h
#ifndef __BLOODBAR_H
#define __BLOODBAR_H
#include "Maps.h"
#include "Character.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供血條													   //
	/////////////////////////////////////////////////////////////////////////////
	class BloodBar
	{
	public:
		BloodBar();
		void loadBloodBar();
		void showBloodBar(Maps *m, int hp);
		void setFullHP(int n);					//設定滿血的血量
		void setXY(int x, int y);				//設定血條的x y 座標
		int getFullHP();						//回傳滿血的血量
	private:
		CMovingBitmap blood_bar[12];			//不同長度的血條
		double full_hp;
		int _x, _y;
	};
}
#endif // !BloodBar_H
BlueGoblin.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Arrow.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "BlueGoblin.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// BlueGoblin: Enemy class												   //
	/////////////////////////////////////////////////////////////////////////////
	BlueGoblin::BlueGoblin()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	BlueGoblin::BlueGoblin(int x, int y, Hero *h) : Enemy(x, y, 1200, "BlueGoblin", h, ICE)
	{
		attack_damage = 20;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));
	}
	BlueGoblin::~BlueGoblin()
	{
	}
	void BlueGoblin::LoadBitmap()
	{
		blood_bar.loadBloodBar();
		/////掉落道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->load();
		}
		/////怪物的動畫
		char *filename1_1[4] = { ".\\bitmaps\\bluegoblinL1.bmp",".\\bitmaps\\bluegoblinL2.bmp",".\\bitmaps\\bluegoblinL3.bmp", ".\\bitmaps\\bluegoblinL4.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[4] = { ".\\bitmaps\\bluegoblinR1.bmp",".\\bitmaps\\bluegoblinR2.bmp",".\\bitmaps\\bluegoblinR3.bmp", ".\\bitmaps\\bluegoblinR4.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		/////攻擊的動畫
		arrowAttackL.LoadBitmap(".\\bitmaps\\blue_arrow_attackL.bmp", RGB(0, 0, 0));
		arrowAttackR.LoadBitmap(".\\bitmaps\\blue_arrow_attackR.bmp", RGB(0, 0, 0));
		arr.loadBitmap();
	}
	void BlueGoblin::OnMove(Maps * m) 
	{
		const int STEP_SIZE = 4;
		if (isAlive()) 
		{
			attack_cool_down -= 1;
			walkingLeft.OnMove();
			walkingRight.OnMove();
			movement(m);
			arrowAttack();
			arr.OnMove(m);
			arrowAttackMove(m);
			if (arrowAttackCD != 0)
			{
				arrowAttackCD--;
			}
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);
		}
	}
	void BlueGoblin::OnShow(Maps *m)
	{
		if (isAlive())
		{									
			if (_direction == 0)					//向左的onShow
			{
				if (isAttacking)
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp - 16);
					arrowAttackShow(m);
				}
				else
				{								
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
				}
				
			}
			else
			{										//向右
				if (isAttacking) 
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
					arrowAttackShow(m);
				}
				else
				{
					
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
				}
			}
		}
		if (!isAlive())
		{
			itemsOnShow(m);
		}
	}
	int BlueGoblin::GetX1()
	{
		return _x;
	}
	int BlueGoblin::GetY1()
	{
		return _y;
	}
	int BlueGoblin::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int BlueGoblin::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void BlueGoblin::Initialize() 
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking = attackIsFlying = false;
		hp = 1200;
		arrorClock = 0;
		arrowAttackCD = 0;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		///道具
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->Initialize();
		}
	}
	bool BlueGoblin::intersect(int x1, int x2, int y1, int y2)
	{
		//下面有一些加減運算是因為，Bitmap本身比身體大太多。
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + walkingRight.Width() - 20 && y2 >= _y + 30 && y1 <= _y + walkingRight.Height() - 15) {
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	void BlueGoblin::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void BlueGoblin::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void BlueGoblin::SetMovingLeft(bool b)
	{
		isMovingLeft = b;
	}
	void BlueGoblin::SetMovingRight(bool b)
	{
		isMovingRight = b;
	}
	void BlueGoblin::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void BlueGoblin::movement(Maps *m)
	{
		int x = GetX1();
		int y1 = GetY1() ;
		if (_x > hero_on_map->GetX1())
		{
			_direction = 0;
		}
		else
		{
			_direction = 1;
		}
		int step_size = rand() % 3;
		if (_x != hero_on_map->GetX1() && _y != hero_on_map->GetY1()) 
		{
			if (abs(_x - hero_on_map->GetX1()) > abs(_y - hero_on_map->GetY1()))
			{
				if (_y > hero_on_map->GetY1())
					_y -= step_size;
				else
					_y += step_size;
			}
			else
			{
				if (_x > hero_on_map->GetX1())
					_x -= step_size;
				else
					_x += step_size;
			}
		}
	}
	void BlueGoblin::attack()
	{
	}
	void BlueGoblin::attackShow(Maps * m)
	{
	}
	void BlueGoblin::arrowAttack()
	{
		if (!isAttacking && arrowAttackCD == 0)
		{
			if (_y == hero_on_map->GetY1() && hero_on_map->GetX1() <= _x)	//如果 y座標跟hero y座標一樣 英雄在左邊 射箭
			{
				arrorClock = 60;											//攻擊會飛兩秒
				arr.setAttackIsFlying(true);
				arr.setDirection(0);										//設定攻擊的方向 向左 因為英雄在左邊
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;							
				arrowAttackCD = 180;										// 攻擊cd為6秒
			}
			if (_y == hero_on_map->GetY1() && hero_on_map->GetX1() > _x)
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(1);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_x == hero_on_map->GetX1() && hero_on_map->GetY1() <= _y )
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(2);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_x == hero_on_map->GetX1() && hero_on_map->GetY1() > _y )
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(3);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
		}
	}
	void BlueGoblin::arrowAttackMove(Maps * m)
	{
		if (isAttacking)
		{
			if (hero_on_map->intercect(arr.getX1(), arr.getX2(), arr.getY1(), arr.getY2())) {
				hero_on_map->offsetHp(attack_damage);
			}
		}
		if (isAttacking && arrorClock != 0) 
		{		//arrorClock每次onMove--
			arrorClock--;
			if (arrorClock == 0) {
				isAttacking = false;				//如果=0 isAttacking = false 離開攻擊狀態
			}
		}
	}
	void BlueGoblin::arrowAttackShow(Maps * m)
	{
		if (isAttacking)
		{
			if (_direction == 0)					//向左的時候
			{
				arrowAttackL.SetTopLeft(m->screenX(_x), m->screenY(_y));
				arrowAttackL.ShowBitmap();
				arr.OnShow(m);
			}
			if (_direction == 1)					//向左的時候
			{
				arrowAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
				arrowAttackR.ShowBitmap();
				arr.OnShow(m);
			}
		}
	}
}

BlueGoblin.h
#ifndef BLUEGOBLIN_H
#define BLUEGOBLIN_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
#include "Arrow.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個敵人												   //
	//一個藍色的哥布林	 													   //
	/////////////////////////////////////////////////////////////////////////////
	class Arrow;
	class BlueGoblin :public Enemy
	{
	public:
		BlueGoblin();						//建構子，傳給Character角色名稱
		BlueGoblin(int x, int y, Hero *h);	//建構子，設定角色初始位置給Character()，方便vector一次建立
		~BlueGoblin();
		void LoadBitmap();					//加載敵人Bitmap
		void OnShow(Maps *m) override;		//顯示敵人於畫面上
		void OnMove(Maps *m);				//敵人移動
		int GetX1();						//回傳最左側X值
		int GetY1();						//回傳最上側Y值
		int GetX2();						//回傳最右側X值
		int GetY2();						//回傳最下側Y值
		void Initialize()override;			//初始化
											//英雄是否和此敵人所在同一位置，前身是cannotPass
		bool intersect(int x1, int x2, int y1, int y2) override;
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);			//設定是否往下左右移動
		void SetMovingUp(bool b);			//上
		void SetMovingLeft(bool b);			//左
		void SetMovingRight(bool b);		//右
		void SetXY(int x, int y);			//決定角色移動的方式
		void movement(Maps *m);	
		///用來攻擊的
		void attack();						//用來判定是否要攻擊
		void attackShow(Maps *m);
		void arrowAttack();					//判定是否要射箭攻擊
		void arrowAttackMove(Maps *m);		//射箭OnMove
		void arrowAttackShow(Maps *m);		//射箭的OnShow
	private:
		CMovingBitmap arrowAttackL;
		CMovingBitmap arrowAttackR;
		CAnimation walkingLeft;
		CAnimation walkingRight;
		Arrow arr;							//class Arrow
		int attack_damage;					//攻擊力
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		bool attackIsFlying;				//攻擊是否正在飛
		int attack_cool_down;				//攻擊的冷卻時間
		int move_or_not;
		int time_bump_into_sth;
		int arrowAttackCD;					//射箭的cd
		int arrorClock;						//箭在空中飛的時間
	};
}
#endif 
BlueSlime.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "BlueSlime.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// BlueGoblin: Enemy class												   //
	/////////////////////////////////////////////////////////////////////////////
	BlueSlime::BlueSlime()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	BlueSlime::BlueSlime(int x, int y, Hero *h) : Enemy(x, y, 1200, "BlueSlime", h, ICE)
	{
		attack_damage = 70;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));				//推給怪物存著他死掉會掉的掉落物
	}
	BlueSlime::~BlueSlime()
	{
	}
	void BlueSlime::LoadBitmap()
	{
		blood_bar.loadBloodBar();
		/////掉落道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->load();
		}
		/////怪物的動畫
		char *filename1_1[3] = { ".\\bitmaps\\blueslimeL1.bmp",".\\bitmaps\\blueslimeL2.bmp",".\\bitmaps\\blueslimeL3.bmp" };
		for (int i = 0; i < 3; i++)	// 載入動畫
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[3] = { ".\\bitmaps\\blueslimeR1.bmp",".\\bitmaps\\blueslimeR2.bmp",".\\bitmaps\\blueslimeR3.bmp"};
		for (int i = 0; i < 3; i++)	// 載入動畫
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		/////攻擊的動畫
		char *filename2_1[5] = { ".\\bitmaps\\blueslime_attackL1.bmp",".\\bitmaps\\blueslime_attackL2.bmp",".\\bitmaps\\blueslime_attackL3.bmp", ".\\bitmaps\\blueslime_attackL4.bmp", ".\\bitmaps\\blueslime_attackL5.bmp" };
		for (int i = 0; i < 5; i++)	// 載入動畫
			normalAttackL.AddBitmap(filename2_1[i], RGB(0, 0, 0));
		normalAttackL.SetDelayCount(3);
		char *filename2_2[5] = { ".\\bitmaps\\blueslime_attackR1.bmp",".\\bitmaps\\blueslime_attackR2.bmp",".\\bitmaps\\blueslime_attackR3.bmp", ".\\bitmaps\\blueslime_attackR4.bmp", ".\\bitmaps\\blueslime_attackR5.bmp" };
		for (int i = 0; i < 5; i++)	// 載入動畫
			normalAttackR.AddBitmap(filename2_2[i], RGB(0, 0, 0));
		normalAttackR.SetDelayCount(3);
	}
	void BlueSlime::OnMove(Maps * m)
	{
		const int STEP_SIZE = 4;
		if (isAlive())
		{						//如果活著
			attack();							//看是否要攻擊
			attack_cool_down -= 1;				//每次onMove減少攻擊的冷卻時間
			walkingLeft.OnMove();
			walkingRight.OnMove();
			movement(m);						//角色移動方式
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);						//如果死掉 掉落道具
		}
	}
	void BlueSlime::OnShow(Maps *m)
	{
		if (isAlive()) 
		{						//如果活著
			if (_direction == 0)				//如果向左
			{
				if (isAttacking) 
				{				//如果在攻擊 會顯示攻擊的動畫
					attackShow(m);
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
				else
				{							//如果不是在攻擊，顯示一般時候的動畫
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
			}
			else
			{									//如果向右
				if (isAttacking)
				{
					attackShow(m);
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
				else 
				{
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
			}
			
		}
		if (!isAlive())
		{						//如果死掉 顯示掉落道具
			itemsOnShow(m);
		}
	}
	int BlueSlime::GetX1()
	{
		return _x;
	}
	int BlueSlime::GetY1()
	{
		return _y;
	}
	int BlueSlime::GetX2()					//x2 = x座標加上寬度
	{
		return _x + walkingRight.Width();
	}
	int BlueSlime::GetY2()					//y2 - y座標加上高度
	{
		return _y + walkingRight.Height();
	}
	void BlueSlime::Initialize()		//初始化
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking =  false;
		hp = 1200;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		///道具
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->Initialize();
		}
	}
	bool BlueSlime::intersect(int x1, int x2, int y1, int y2)
	{
		//下面有一些加減運算是因為，Bitmap本身比身體大太多。
		if (isAlive())
		{
			if (x2 >= _x + 20 && x1 <= _x + walkingRight.Width() - 20 && y2 >= _y + 30 && y1 <= _y + walkingRight.Height() - 15) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;

	}
	void BlueSlime::SetMovingDown(bool b)
	{
		isMovingDown = b;
	}
	void BlueSlime::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void BlueSlime::SetMovingLeft(bool b)
	{
		isMovingLeft = b;
	}
	void BlueSlime::SetMovingRight(bool b) 
	{
		isMovingRight = b;
	}
	void BlueSlime::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void BlueSlime::movement(Maps *m)
	{
		int x = GetX1();
		int y1 = GetY1() ;	
		int step_size = rand() % 3;				//每次移動 1-3步
		if (distanceToHero() < 500) 
		{	//如果跟hero的距離<500才會開始動
			if (hero_on_map->GetX1() > x && m->isEmpty(GetX2() + step_size, y1) && m->isEmpty(GetX2() + step_size, GetY2())) {
				_direction = 1;					//如果英雄在右邊 向右走
				_x += step_size;
			}
			if (hero_on_map->GetX1() < x && m->isEmpty(x - step_size, y1) && m->isEmpty(x - step_size, GetY2())) {
				_direction = 0;					//如果英雄在左邊，向左走
				_x -= step_size;
			}
			if (hero_on_map->GetY1() > y1 && m->isEmpty(x, GetY2() + step_size) && m->isEmpty(GetX2(), GetY2() + step_size)) {
				_y += step_size;				//如果英雄在下面，向下走
			}
			if (hero_on_map->GetY1() < y1 && m->isEmpty(x, y1 - step_size) && m->isEmpty(GetX2(), y1 - step_size)) {
				_y -= step_size;				//如果英雄在上面，向下走
			}
		}
	}
	void BlueSlime::attack()		//如果英雄在攻擊範圍內，且攻擊冷卻時間已經到了，會攻擊
	{
		if (intersect(hero_on_map->GetX1(), hero_on_map->GetX2(), hero_on_map->GetY1(), hero_on_map->GetY2()) && attack_cool_down <= 0 && !isAttacking)
		{
			CAudio::Instance()->Play(AUDIO_HITTING);
			isAttacking = true;
			hero_on_map->offsetHp(attack_damage);			//英雄扣血
		}
		normalAttackR.OnMove();
		if (!isAttacking)
		{
			normalAttackR.Reset();
		}
	}
	void BlueSlime::attackShow(Maps * m)
	{
		if (isAttacking) 
		{//如果正在攻擊，顯示攻擊的動畫
			normalAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
			normalAttackR.OnShow();
			if (normalAttackR.IsFinalBitmap())
			{
				isAttacking = false;
				attack_cool_down = 90; //每次攻擊間隔3秒
			}
		}
	}
}

BlueSlime.h
#ifndef BLUESLIME_H
#define BLUESLIME_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個敵人													   //
	//一個藍色的史萊姆	 													   //
	/////////////////////////////////////////////////////////////////////////////
	class BlueSlime :public Enemy
	{
	public:
		BlueSlime();						//建構子，傳給Character角色名稱
		BlueSlime(int x, int y, Hero *h);	//建構子，設定角色初始位置給Character()，方便vector一次建立
		~BlueSlime();
		void LoadBitmap();					//加載敵人Bitmap
		void OnShow(Maps *m) override;		//顯示敵人於畫面上
		void OnMove(Maps *m);				//敵人移動
		int GetX1();						//回傳最左側X值
		int GetY1();						//回傳最上側Y值
		int GetX2();						//回傳最右側X值
		int GetY2();						//回傳最下側Y值
		void Initialize()override;			//初始化
											//英雄是否和此敵人所在同一位置，前身是cannotPass
		bool intersect(int x1, int x2, int y1, int y2) override;
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);					//下
		void SetMovingUp(bool b);					//上
		void SetMovingLeft(bool b);					//左
		void SetMovingRight(bool b);				//右
		void SetXY(int x, int y);					//x, y座標
		void movement(Maps *m);
		void attack();
		void attackShow(Maps *m);
	private:
		CAnimation walkingLeft;
		CAnimation walkingRight;
		CAnimation normalAttackL;
		CAnimation normalAttackR;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		int attack_cool_down;
		int move_or_not;
		int time_bump_into_sth;
	};
}
#endif 
BossBloodBar.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "BossBloodBar.h"
namespace game_framework 
{
	BossBloodBar::BossBloodBar()
	{
		_x = 0;
		_y = 0;
		full_hp = 0;
	}
	void BossBloodBar::setFullHP(int n)
	{
		full_hp = n;
	}
	void BossBloodBar::setXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	int BossBloodBar::getFullHP()
	{
		return (int)full_hp;
	}
	void BossBloodBar::loadBloodBar()
	{
		blood_bar[0].LoadBitmap(".\\bitmaps\\boss_blood_almost_die.bmp", RGB(0, 0, 0));
		blood_bar[1].LoadBitmap(".\\bitmaps\\boss_blood_almost_die.bmp", RGB(0, 0, 0));
		blood_bar[2].LoadBitmap(".\\bitmaps\\boss_blood14.bmp", RGB(0, 0, 0));
		blood_bar[3].LoadBitmap(".\\bitmaps\\boss_blood3over10.bmp", RGB(0, 0, 0));
		blood_bar[4].LoadBitmap(".\\bitmaps\\boss_blood4over10.bmp", RGB(0, 0, 0));
		blood_bar[5].LoadBitmap(".\\bitmaps\\boss_blood12.bmp", RGB(0, 0, 0));
		blood_bar[6].LoadBitmap(".\\bitmaps\\boss_blood6over10.bmp", RGB(0, 0, 0));
		blood_bar[7].LoadBitmap(".\\bitmaps\\boss_blood7over10.bmp", RGB(0, 0, 0));
		blood_bar[8].LoadBitmap(".\\bitmaps\\boss_blood34.bmp", RGB(0, 0, 0));
		blood_bar[9].LoadBitmap(".\\bitmaps\\boss_blood8over10.bmp", RGB(0, 0, 0));
		blood_bar[10].LoadBitmap(".\\bitmaps\\boss_blood_little_damaged.bmp", RGB(0, 0, 0));
		blood_bar[11].LoadBitmap(".\\bitmaps\\boss_blood_full.bmp", RGB(0, 0, 0));
	}
	void BossBloodBar::showBloodBar(Maps *m1, int hp)
	{
		if (hp > full_hp) {
			setFullHP(hp);
		}
		double proportion = hp / full_hp;
		if (proportion < 1.0 / 9) 
		{
			blood_bar[0].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[0].ShowBitmap();
		}
		else if (proportion < 2.0 / 10)
		{
			blood_bar[1].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[1].ShowBitmap();
		}
		else if (proportion < 1.0 / 4)
		{
			blood_bar[2].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[2].ShowBitmap();
		}
		else if (proportion < 3.0/10)
		{
			blood_bar[3].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[3].ShowBitmap();
		}
		else if (proportion < 4.0/10) 
		{
			blood_bar[4].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[4].ShowBitmap();
		}
		else if (proportion < 5.0 / 10)
		{
			blood_bar[5].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[5].ShowBitmap();
		}
		else if (proportion < 6.0 / 10)
		{
			blood_bar[6].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[6].ShowBitmap();
		}
		else if (proportion < 7.0 / 10)
		{
			blood_bar[7].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[7].ShowBitmap();
		}
		else if (proportion < 3.0 / 4)
		{
			blood_bar[8].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[8].ShowBitmap();
		}
		else if (proportion < 8.0 / 10) 
		{
			blood_bar[9].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[9].ShowBitmap();
		}
		else if (proportion < 9.0 / 10) 
		{
			blood_bar[10].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[10].ShowBitmap();
		}
		else 
		{
			blood_bar[11].SetTopLeft(m1->screenX(_x), m1->screenY(_y - 20));
			blood_bar[11].ShowBitmap();
		}
	}
}

BossBloodBar.h
#ifndef __BOSSBLOODBAR_H
#define __BOSSBLOODBAR_H
#include "Maps.h"
#include "Character.h"
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供boss的血條												   //
	/////////////////////////////////////////////////////////////////////////////
	class BossBloodBar
	{
	public:
		BossBloodBar();
		void loadBloodBar();
		void showBloodBar(Maps *m, int hp);
		void setFullHP(int n);
		void setXY(int x, int y);
		int getFullHP();
	private:
		CMovingBitmap blood_bar[12];
		double full_hp;
		int _x, _y;
	};
}
#endif 
Box.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "Box.h"
#include "Util.h"
#include "Item.h"
#include "Clock.h"
#include "Potion.h"
#include "RandomAttribute.h"
#include "Shoe.h"
#include "ProtectiveCover.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// Box: Enemy class														   //
	/////////////////////////////////////////////////////////////////////////////
	Box::Box()
	{
		_x = 384;
		_y = 384;
		hp = 2;
		attack_damage = 0;
	}
	Box::Box(int x, int y, Hero *h) : Enemy(x, y, 1200, "Box", h, NO)
	{
		attack_damage = 0;
		attack_cool_down = 0;
		items.push_back(new Potion());				//push_back道具到箱子裡面，箱子被打掉會掉落道具
		items.push_back(new Clock());
		items.push_back(new RandomAttribute());
		items.push_back(new Shoe());
		items.push_back(new ProtectiveCover());
	}
	Box::~Box()
	{
	}
	void Box::LoadBitmap()
	{
		box.LoadBitmap(IDB_BOX, RGB(0, 0, 0));
		damaged_box.LoadBitmap(IDB_BOXDAMAGED, RGB(0, 0, 0));
		////道具
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->load();
		}
		blood_bar.loadBloodBar();
		EnemyRect = box.ReturnCRect();
	}
	void Box::OnMove(Maps * m) 
	{
		if (isAlive())
		{
			m->setPos(_x + 20, _y + 20, 1);
		}
		if (!isAlive()) 
		{
			m->setPos(_x + 20, _y + 20, 0);
			itemsOnMove(m);
		}
	}
	void Box::OnShow(Maps *m)
	{
		if (isAlive())
		{
			if (hp > 10) 
			{
				box.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
				box.ShowBitmap();
			}
			if (hp <= 10)
			{
				damaged_box.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
				damaged_box.ShowBitmap();
			}
		}
		if (!isAlive())
		{
			itemsOnShow(m);
		}
	}
	int Box::GetX1()
	{
		return _x;
	}
	int Box::GetY1()
	{
		return _y;
	}
	int Box::GetX2()
	{
		return _x + box.Width();
	}
	int Box::GetY2()
	{
		return _y + box.Height();
	}
	void Box::Initialize() 
	{
		hp = 20;
		rand_num = rand();
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = false;
		blood_bar.setFullHP(hp);
		////道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->Initialize();
			items.at(i)->setNumOfBox(rand_num);
		}
	}
	bool Box::intersect(int x1, int x2, int y1, int y2)
	{
		//下面有一些加減運算是因為，稻草人的Bitmap本身比稻草人的身體大太多。
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + box.Width() - 20 && y2 >= _y && y1 <= _y + box.Height() - 15) {
				return true;
			}
			else
			{
				return false;
			}
		}
		return false;
	}
	void Box::SetMovingDown(bool b)
	{
		isMovingDown = b;
	}
	void Box::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void Box::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void Box::SetMovingRight(bool b) 
	{
		isMovingRight = b;
	}
	void Box::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void Box::attack()
	{
	}
	void Box::attackShow(Maps * m)
	{
	}
}

Box.h
#ifndef BOX_H
#define BOX_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個箱子												   //
	/////////////////////////////////////////////////////////////////////////////
	class Box :public Enemy
	{
	public:
		Box();									//建構子，傳給Character角色名稱
		Box(int x, int y, Hero *h);				//建構子，設定角色初始位置給Character()，方便vector一次建立
		~Box();
		void LoadBitmap();						//加載敵人Bitmap
		void OnShow(Maps *m) override;			//顯示敵人於畫面上
		void OnMove(Maps *m);					//敵人移動
		int GetX1();							//回傳最左側X值
		int GetY1();							//回傳最上側Y值
		int GetX2();							//回傳最右側X值
		int GetY2();							//回傳最下側Y值
		void Initialize()override;				//初始化
		//英雄是否和此敵人所在同一位置，前身是cannotPass
		bool intersect(int x1, int x2, int y1, int y2) override;
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);					//下
		void SetMovingUp(bool b);					//上
		void SetMovingLeft(bool b);					//左
		void SetMovingRight(bool b);				//右
		void SetXY(int x, int y);					//x, y座標
		//用來攻擊的
		void attack();
		void attackShow(Maps *m);
	private:
		CMovingBitmap box;
		CMovingBitmap damaged_box;		//有裂痕的箱子
		int rand_num;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		int attack_cool_down;
	};
}
#endif // !Scarecrow_H
Character.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Potion.h"
#include "Clock.h"
#include "Character.h"
namespace game_framework {
	string Character::getName()
	{
		return _name;
	}
}

Character.h
#ifndef CHARACTER_H
#define CHARACTER_H
#include "Maps.h"
namespace game_framework {
	class Character
	{
	protected:
		Character(string name) {				//每個角色都會有名稱，就像學名一樣，一對應一種
			_name = name;
		}
		Character() {
		}
		string getName();						//回傳角色名稱
		virtual void OnShow(Maps *m) {};
		int movement_speed;
	private:
		string _name;
	};
}
#endif
Clock.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "Clock.h"
namespace game_framework 
{
	Clock::Clock()
	{
	}
	void Clock::load()
	{
		clock_pic.LoadBitmap(IDB_ITEMCLOCK);
		item_on_status_bar.LoadBitmapA(IDB_ITEMCLOCK);
	}
	void Clock::OnMove(Maps *m, Hero *h)
	{
		_x = getX();
		_y = getY();
		if (isExist() && intercect(h) && getNumOfBox() % 100 > 40 && getNumOfBox() % 100 <= 50) 
		{ //如果num_ofBox%100 = 40-50 箱子會掉這個道具
			Clock * p = new Clock();
			p->load();
			h->addItem(p);				//如果英雄撿到，會被推進道具欄
			setExist(false);
		}
	}
	void Clock::OnShow(Maps *m)
	{
		if (isExist() && getNumOfBox() % 100 > 40 && getNumOfBox() % 100 <= 50)
		{
			clock_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
			clock_pic.ShowBitmap();
		}
	}
	void Clock::effect(Hero *h)
	{
		h->SetAllCoolDownToZero();			//將英雄的技能冷卻時間全部重製
		setIsUsed(false);
	}
	bool Clock::intercect(Hero * h)
	{
		if (isExist()) 
		{
			if (h->GetX2() >= _x + 10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
}

Clock.h
#ifndef __CLOCK_H
#define __CLOCK_H
#include "Maps.h"
#include "Character.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具，可以重製所有招式的冷卻時間						   //
	// 道具可由箱子或擊殺怪物獲得											   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class Clock: public Item
	{
	public:
		Clock();
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		void effect(Hero *h);				//使用道具的效果
		bool intercect(Hero *h) ;
	private:
		int _x, _y;
		CMovingBitmap clock_pic;
	};
}
#endif
Enemy.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Potion.h"
#include "Clock.h"
namespace game_framework 
{
	Enemy::Enemy() : Character("scarecrow")
	{
		_x = 384;
		_y = 384;
		hp = 1200;
		attack = 0;
	}
	Enemy::Enemy(int x, int y, int monsterHp, string name, Hero *h, ELEMENT_ATTRIBUTE a) : Character(name)
	{
		_x = x;
		_y = y;
		ini_x = x;
		ini_y = y;
		hp = monsterHp;
		full_hp = monsterHp;
		attack = 0;
		isAttacking = false;
		hero_on_map = h;
		_attribute = a;
		if (GetName() != "Box")
		{
			items.push_back(new Health(monsterHp/40));
		}
	}
	Enemy::~Enemy()
	{
		for (vector<Item*>::iterator it_i = items.begin(); it_i != items.end(); ++it_i)
		{
			delete *it_i;
		}
	}
	int Enemy::distanceToHero()
	{
		if (getName() == "scarecrow") 
		{
			int x_distance = (_x + 32) - (hero_on_map->GetX1() + 30);
			int y_distance = (_y + 96) - (hero_on_map->GetY1() + 35);
			return (int)(sqrt(pow(x_distance, 2) + pow(y_distance, 2)));
		}
		else if (getName() == "IceBird") 
		{
			int x_distance = (_x + 128) - (hero_on_map->GetX1() + 30);
			int y_distance = (_y + 128) - (hero_on_map->GetY1() + 35);
			return (int)(sqrt(pow(x_distance, 2) + pow(y_distance, 2)));
		}
		else if (getName() == "ABoss") 
		{
			int x_distance = (_x + 96) - (hero_on_map->GetX1() + 30);
			int y_distance = (_y + 96) - (hero_on_map->GetY1() + 35);
			return (int)(sqrt(pow(x_distance, 2) + pow(y_distance, 2)));
		}
		else 
		{
			int x_distance = (_x + 32) - (hero_on_map->GetX1() + 30);
			int y_distance = (_y + 32) - (hero_on_map->GetY1() + 35);
			return (int)(sqrt(pow(x_distance, 2) + pow(y_distance, 2)));
		}
	}
	double Enemy::hpProportion()
	{
		return (double)(hp) / full_hp;
	}
	void Enemy::SetMovingDown(bool b)
	{
		isMovingDown = b;
	}
	void Enemy::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void Enemy::SetMovingLeft(bool b)
	{
		isMovingLeft = b;
	}
	void Enemy::SetMovingRight(bool b)
	{
		isMovingRight = b;
	}
	void Enemy::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void Enemy::offsetHP(int offset, ELEMENT_ATTRIBUTE attribute)
	{
		if (GetName() == "Box")
		{
			hp -= 1;
		}
		else 
		{
			if (isCounterAttribute(_attribute, attribute))
			{
				hp += (offset * 2);

			}
			else if (isCounterAttribute(attribute, _attribute)) 
			{
				hp += (offset / 2);
			}
			else 
			{
				hp += offset;
			}
			knockBack();
		}
	}
	void Enemy::itemsOnMove(Maps * m)
	{
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->OnMove(m, hero_on_map);
		}
	}
	void Enemy::itemsOnShow(Maps *m)
	{
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->setXY(_x + 32, _y + 32);
			items.at(i)->OnShow(m);
		}
	}
	bool Enemy::isAlive()
	{
		if (hp <= 0)
		{
			return false;
		}
		return true;
	}
	bool Enemy::isAttack()
	{
		return isAttacking;
	}
	bool Enemy::isCounterAttribute(ELEMENT_ATTRIBUTE a, ELEMENT_ATTRIBUTE b)
	{
		if (a == FIRE) 
		{
			if (b == ICE) 
			{
				return true;
			}
		}
		if (a == ICE)
		{
			if (b == PLANT)
			{
				return true;
			}
		}
		if (a == PLANT)
		{
			if (b == FIRE) 
			{
				return true;
			}
		}
		return false;
	}
	void Enemy::knockBack()
	{
		if (_direction == 0) 
		{
			_x += 1;
		}
		if (_direction == 1)
		{
			_x -= 1;
		}
	}
	string Enemy::GetName()
	{
		return getName();
	}
}

Enemy.h
#ifndef ENEMY_H
#define ENEMY_H

#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Util.h"
#include "Item.h"
#include "Health.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class是敵人的共同介面    											   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class Enemy :public Character
	{
	public:
		Enemy();											//建構子，傳給Character角色名稱
		Enemy(int x, int y, int hp, string name, Hero *h, ELEMENT_ATTRIBUTE a);			//建構子，設定角色初始位置給Character()，方便vector一次建立
		virtual ~Enemy();
		virtual void LoadBitmap() = 0;				//加載敵人Bitmap
		virtual void OnShow(Maps *m) = 0;			//顯示敵人於畫面上
		virtual void OnMove(Maps *m) = 0;			//敵人移動
		virtual int GetX1() = 0;					//回傳最左側X值
		virtual int GetY1() = 0;					//回傳最上側Y值
		virtual int GetX2() = 0;					//回傳最右側X值
		virtual int GetY2() = 0;					//回傳最下側Y值
		string GetName();
		virtual void Initialize() = 0;				//初始化
		//英雄是否和此敵人所在同一位置，前身是cannotPass
		virtual bool intersect(int x1, int x2, int y1, int y2) = 0;
		int distanceToHero();
		double hpProportion();
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);					//下
		void SetMovingUp(bool b);					//上
		void SetMovingLeft(bool b);					//左
		void SetMovingRight(bool b);				//右
		void SetXY(int x, int y);					//x, y座標
		void offsetHP(int offset, ELEMENT_ATTRIBUTE attribute);		//增減此Enemy的血量(enemys->at->heroExistingArea(的攻擊範圍作增減))
		void itemsOnMove(Maps *m);
		void itemsOnShow(Maps *m);
		bool isAlive();
		bool isAttack();
		bool isCounterAttribute(ELEMENT_ATTRIBUTE a, ELEMENT_ATTRIBUTE b);
		void knockBack();
	protected:
		Hero * hero_on_map;
		BloodBar blood_bar;
		vector<Item *> items;
		CRect EnemyRect;
		int _x, _y;
		int ini_x, ini_y;
		int hp;
		int full_hp;
		int attack;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		int _direction;
		ELEMENT_ATTRIBUTE _attribute;
	};
}
#endif
GreenGoblin.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Arrow.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "GreenGoblin.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueGoblin.cpp 												   //
	/////////////////////////////////////////////////////////////////////////////
	GreenGoblin::GreenGoblin()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	GreenGoblin::GreenGoblin(int x, int y, Hero *h) : Enemy(x, y, 1200, "GreenGoblin", h, FIRE)
	{
		attack_damage = 20;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));
	}
	GreenGoblin::~GreenGoblin()
	{
	}
	void GreenGoblin::LoadBitmap()
	{
		blood_bar.loadBloodBar();
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->load();
		}
		char *filename1_1[4] = { ".\\bitmaps\\greengoblinL1.bmp",".\\bitmaps\\greengoblinL2.bmp",".\\bitmaps\\greengoblinL3.bmp", ".\\bitmaps\\greengoblinL4.bmp" };
		for (int i = 0; i < 4; i++)
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[4] = { ".\\bitmaps\\greengoblinR1.bmp",".\\bitmaps\\greengoblinR2.bmp",".\\bitmaps\\greengoblinR3.bmp", ".\\bitmaps\\greengoblinR4.bmp" };
		for (int i = 0; i < 4; i++)
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		arrowAttackL.LoadBitmap(".\\bitmaps\\green_arrow_attackL.bmp", RGB(0, 0, 0));
		arrowAttackR.LoadBitmap(".\\bitmaps\\green_arrow_attackR.bmp", RGB(0, 0, 0));
		arr.loadBitmap();
	}
	void GreenGoblin::OnMove(Maps * m)
	{
		const int STEP_SIZE = 4;
		if (isAlive()) {
			//attack();
			attack_cool_down -= 1;
			//arrowAttackCD -= 1;
			walkingLeft.OnMove();
			walkingRight.OnMove();
			movement(m);
			arrowAttack();
			arr.OnMove(m);
			arrowAttackMove(m);
			if (arrowAttackCD != 0)
			{
				arrowAttackCD--;
			}
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);
		}
	}
	void GreenGoblin::OnShow(Maps *m)
	{
		if (isAlive()) 
		{
			if (_direction == 0)
			{
				if (isAttacking)
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp - 16);
					arrowAttackShow(m);
				}
				else 
				{
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
				}
			}
			else
			{
				if (isAttacking)
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
					arrowAttackShow(m);
				}
				else 
				{
					
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
				}
			}
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int GreenGoblin::GetX1()
	{
		return _x;
	}
	int GreenGoblin::GetY1()
	{
		return _y;
	}
	int GreenGoblin::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int GreenGoblin::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void GreenGoblin::Initialize() 
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking = attackIsFlying = false;
		hp = 1200;
		arrorClock = 0;
		arrowAttackCD = 0;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		for (unsigned i = 0; i < items.size(); i++) {
			items.at(i)->Initialize();
		}
	}
	bool GreenGoblin::intersect(int x1, int x2, int y1, int y2)
	{
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + walkingRight.Width() - 20 && y2 >= _y + 30 && y1 <= _y + walkingRight.Height() - 15) 
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		return false;
	}
	void GreenGoblin::SetMovingDown(bool b)
	{
		isMovingDown = b;
	}
	void GreenGoblin::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void GreenGoblin::SetMovingLeft(bool b)
	{
		isMovingLeft = b;
	}
	void GreenGoblin::SetMovingRight(bool b)
	{
		isMovingRight = b;
	}
	void GreenGoblin::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void GreenGoblin::movement(Maps *m)
	{
		int x = GetX1();
		int y1 = GetY1() ;
		if (_x > hero_on_map->GetX1()) 
		{
			_direction = 0;
		}
		else 
		{
			_direction = 1;
		}
		int step_size = rand() % 3;
		if (_x != hero_on_map->GetX1() && _y != hero_on_map->GetY1())
		{
			if (abs(_x - hero_on_map->GetX1()) > abs(_y - hero_on_map->GetY1()))
			{
				if (_y > hero_on_map->GetY1())
					_y -= step_size;
				else
					_y += step_size;
			}
			else
			{
				if (_x > hero_on_map->GetX1())
					_x -= step_size;
				else
					_x += step_size;
			}
		}
	}
	void GreenGoblin::attack()
	{
	}
	void GreenGoblin::attackShow(Maps * m)
	{
	}
	void GreenGoblin::arrowAttack()
	{
		if (!isAttacking && arrowAttackCD == 0)
		{
			if (_y == hero_on_map->GetY1() && hero_on_map->GetX1() <= _x)
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(0);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_y == hero_on_map->GetY1() && hero_on_map->GetX1() > _x)
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(1);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_x == hero_on_map->GetX1() && hero_on_map->GetY1() <= _y )
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(2);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_x == hero_on_map->GetX1() && hero_on_map->GetY1() > _y )
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(3);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
		}
	}
	void GreenGoblin::arrowAttackMove(Maps * m)
	{
		if (isAttacking) {
			if (hero_on_map->intercect(arr.getX1(), arr.getX2(), arr.getY1(), arr.getY2())) {
				hero_on_map->offsetHp(attack_damage);
			}
		}
		if (isAttacking && arrorClock != 0) 
		{
			arrorClock--;
			if (arrorClock == 0) {
				isAttacking = false;
			}
		}
	}
	void GreenGoblin::arrowAttackShow(Maps * m)
	{
		if (isAttacking) {
			if (_direction == 0)
			{
				arrowAttackL.SetTopLeft(m->screenX(_x), m->screenY(_y));
				arrowAttackL.ShowBitmap();
				arr.OnShow(m);
			}
			if (_direction == 1)
			{
				arrowAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
				arrowAttackR.ShowBitmap();
				arr.OnShow(m);
			}
		}
	}
}

GreenGoblin.h
#ifndef GREENGOBLIN_H
#define GREENGOBLIN_H

#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
#include "Arrow.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueGoblin.h 												   //
	/////////////////////////////////////////////////////////////////////////////
	class Arrow;
	class GreenGoblin :public Enemy
	{
	public:
		GreenGoblin();
		GreenGoblin(int x, int y, Hero *h);
		~GreenGoblin();
		void LoadBitmap();	
		void OnShow(Maps *m) override;
		void OnMove(Maps *m);
		int GetX1();
		int GetY1();
		int GetX2();
		int GetY2();
		void Initialize()override;
		bool intersect(int x1, int x2, int y1, int y2) override;
		void SetMovingDown(bool b);
		void SetMovingUp(bool b);
		void SetMovingLeft(bool b);
		void SetMovingRight(bool b);
		void SetXY(int x, int y);
		void movement(Maps *m);
		void attack();
		void attackShow(Maps *m);
		void arrowAttack();
		void arrowAttackMove(Maps *m);
		void arrowAttackShow(Maps *m);
	private:
		CMovingBitmap arrowAttackL;
		CMovingBitmap arrowAttackR;
		CAnimation walkingLeft;
		CAnimation walkingRight;
		Arrow arr;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		bool attackIsFlying;
		int attack_cool_down;
		int move_or_not;
		int time_bump_into_sth;
		int arrowAttackCD;
		int arrorClock;
	};
}
#endif 
GreenSlime.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "GreenSlime.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueSlime.cpp												   //
	/////////////////////////////////////////////////////////////////////////////
	GreenSlime::GreenSlime()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	GreenSlime::GreenSlime(int x, int y, Hero *h) : Enemy(x, y, 1200, "GreenSlime", h, PLANT)
	{
		attack_damage = 70;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));
	}
	GreenSlime::~GreenSlime()
	{
	}
	void GreenSlime::LoadBitmap()
	{
		blood_bar.loadBloodBar();
		/////掉落道具
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->load();
		}
		char *filename1_1[3] = { ".\\bitmaps\\greenslimeL1.bmp",".\\bitmaps\\greenslimeL2.bmp",".\\bitmaps\\greenslimeL3.bmp" };
		for (int i = 0; i < 3; i++)
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[3] = { ".\\bitmaps\\greenslimeR1.bmp",".\\bitmaps\\greenslimeR2.bmp",".\\bitmaps\\greenslimeR3.bmp"};
		for (int i = 0; i < 3; i++)
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		char *filename2_1[5] = { ".\\bitmaps\\greenslime_attackL1.bmp",".\\bitmaps\\greenslime_attackL2.bmp",".\\bitmaps\\greenslime_attackL3.bmp", ".\\bitmaps\\greenslime_attackL4.bmp", ".\\bitmaps\\greenslime_attackL5.bmp" };
		for (int i = 0; i < 5; i++)
			normalAttackL.AddBitmap(filename2_1[i], RGB(0, 0, 0));
		normalAttackL.SetDelayCount(3);
		char *filename2_2[5] = { ".\\bitmaps\\greenslime_attackR1.bmp",".\\bitmaps\\greenslime_attackR2.bmp",".\\bitmaps\\greenslime_attackR3.bmp", ".\\bitmaps\\greenslime_attackR4.bmp", ".\\bitmaps\\greenslime_attackR5.bmp" };
		for (int i = 0; i < 5; i++)
			normalAttackR.AddBitmap(filename2_2[i], RGB(0, 0, 0));
		normalAttackR.SetDelayCount(3);
	}
	void GreenSlime::OnMove(Maps * m)
	{
		const int STEP_SIZE = 4;
		if (isAlive()) 
		{
			attack();
			attack_cool_down -= 1;
			walkingLeft.OnMove();
			walkingRight.OnMove();
			movement(m);
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);
		}
	}
	void GreenSlime::OnShow(Maps *m)
	{
		if (isAlive())
		{
			if (_direction == 0)
			{
				if (isAttacking)
				{
					attackShow(m);
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
				else 
				{
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
			}
			else
			{
				if (isAttacking) 
				{
					attackShow(m);
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
				else 
				{
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
			}
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int GreenSlime::GetX1()
	{
		return _x;
	}
	int GreenSlime::GetY1()
	{
		return _y;
	}
	int GreenSlime::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int GreenSlime::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void GreenSlime::Initialize()
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking =  false;
		hp = 1200;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->Initialize();
		}
	}
	bool GreenSlime::intersect(int x1, int x2, int y1, int y2)
	{
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + walkingRight.Width() - 20 && y2 >= _y + 30 && y1 <= _y + walkingRight.Height() - 15) {
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	void GreenSlime::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void GreenSlime::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void GreenSlime::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void GreenSlime::SetMovingRight(bool b) 
	{
		isMovingRight = b;
	}
	void GreenSlime::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void GreenSlime::movement(Maps *m)
	{
		int x = GetX1();
		int y1 = GetY1() ;
		int step_size = rand() % 3;
		if (distanceToHero() < 500)
		{
			if (hero_on_map->GetX1() > x && m->isEmpty(GetX2() + step_size, y1) && m->isEmpty(GetX2() + step_size, GetY2()))
			{
				_direction = 1;
				_x += step_size;
			}
			if (hero_on_map->GetX1() < x && m->isEmpty(x - step_size, y1) && m->isEmpty(x - step_size, GetY2()))
			{
				_direction = 0;
				_x -= step_size;
			}
			if (hero_on_map->GetY1() > y1 && m->isEmpty(x, GetY2() + step_size) && m->isEmpty(GetX2(), GetY2() + step_size))
			{
				_y += step_size;
			}
			if (hero_on_map->GetY1() < y1 && m->isEmpty(x, y1 - step_size) && m->isEmpty(GetX2(), y1 - step_size))
			{
				_y -= step_size;
			}
		}
	}
	void GreenSlime::attack()
	{
		if (intersect(hero_on_map->GetX1(), hero_on_map->GetX2(), hero_on_map->GetY1(), hero_on_map->GetY2()) && attack_cool_down <= 0 && !isAttacking)
		{
			CAudio::Instance()->Play(AUDIO_HITTING);
			isAttacking = true;
			hero_on_map->offsetHp(attack_damage);
		}
		normalAttackR.OnMove();
		if (!isAttacking) 
		{
			normalAttackR.Reset();
		}
	}
	void GreenSlime::attackShow(Maps * m)
	{
		if (isAttacking)
		{
			normalAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
			normalAttackR.OnShow();
			if (normalAttackR.IsFinalBitmap()) 
			{
				isAttacking = false;
				attack_cool_down = 90;

			}
		}
	}
}

GreenSlime.h
#ifndef GREENSLIME_H
#define GREENSLIME_H

#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueSlime.h 													   //
	/////////////////////////////////////////////////////////////////////////////
	class GreenSlime :public Enemy
	{
	public:
		GreenSlime();
		GreenSlime(int x, int y, Hero *h);
		~GreenSlime();
		void LoadBitmap();
		void OnShow(Maps *m) override;
		void OnMove(Maps *m);
		int GetX1();
		int GetY1();
		int GetX2();
		int GetY2();
		void Initialize()override;
		bool intersect(int x1, int x2, int y1, int y2) override;
		void SetMovingDown(bool b);
		void SetMovingUp(bool b);
		void SetMovingLeft(bool b);
		void SetMovingRight(bool b);
		void SetXY(int x, int y);
		void movement(Maps *m);
		void attack();
		void attackShow(Maps *m);
	private:
		CAnimation walkingLeft;
		CAnimation walkingRight;
		CAnimation normalAttackL;
		CAnimation normalAttackR;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		int attack_cool_down;
		int move_or_not;
		int time_bump_into_sth;
	};
}
#endif
Health.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "Health.h"
namespace game_framework
{
	Health::Health(int n)											
	{
		to_heal = n;
	}
	void Health::load()
	{
		health_pic.LoadBitmap(IDB_ITEMHEALTH, RGB(0, 0, 0));
	}
	void Health::OnMove(Maps *m, Hero *h)
	{
		if (isExist() && intercect(h)) 
		{										//如果英雄撿到加生命 撿到後就不存在地圖上了
			h->addHp(to_heal);
			setExist(false);
		}
	}
	void Health::OnShow(Maps *m)
	{
		if (isExist())
		{
			health_pic.SetTopLeft(m->screenX(getX()), m->screenY(getY()));
			health_pic.ShowBitmap();
		}
	}
	void Health::effect(Hero *h)				//因為不是主動使用的道具 所以不用effect
	{
	}
}

Health.h
#ifndef __HEALTH_H
#define __HEALTH_H
#include "Maps.h"
#include "Character.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具 : 永久增加生命值										   //
	// 道具可由箱子或擊殺怪物獲得												   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class Health: public Item
	{
	public:
		Health(int n);
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		void effect(Hero *h);				
	private:
		CMovingBitmap health_pic;
		int to_heal;						//要回復多少生命
	};
}
#endif
Hero.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "BloodBar.h"
#include "Util.h"
#include "Attack.h"
#define HMS movement_speed
namespace game_framework
{
	Hero::Hero() : Character("Hero")
	{
		/*x = 480;
		y = 480;
		hp = 1200;
		attack = 20;
		skillTimes = 0;*/
		for (int i = 0; i < 6; i++)
		{
			items.push_back(nullptr);
		}
	}
	Hero::~Hero() 
	{
		for (vector<Item*>::iterator it_i = items.begin(); it_i != items.end(); ++it_i) 
		{
			delete *it_i;
		}
	}
	void Hero::LoadBitmap()
	{
		heroL.LoadBitmap(IDB_HERO_L, RGB(0, 0, 0));
		heroR.LoadBitmap(IDB_HERO_R, RGB(0, 0, 0));	//如果要測這行要註解掉
		shadeL.LoadBitmap(".\\bitmaps\\skillW_shadeL.bmp", RGB(0, 0, 0));
		shadeR.LoadBitmap(".\\bitmaps\\skillW_shadeR.bmp", RGB(0, 0, 0));
		blood_bar.loadBloodBar();
		//被攻擊
		char *filename_attacked[4] = { ".\\bitmaps\\getting_attacked.bmp",".\\bitmaps\\getting_attacked2.bmp",".\\bitmaps\\getting_attacked.bmp",".\\bitmaps\\getting_attacked2.bmp"};
		for (int i = 0; i < 4; i++)	// 載入動畫
			get_attacked.AddBitmap(filename_attacked[i], RGB(0, 0, 0));
		get_attacked.SetDelayCount(2);
		//向左走動畫
		char *filename1[6] = { ".\\bitmaps\\walkingL1.bmp",".\\bitmaps\\walkingL2.bmp",".\\bitmaps\\walkingL3.bmp",".\\bitmaps\\walkingL4.bmp", ".\\bitmaps\\walkingL3.bmp", ".\\bitmaps\\walkingL2.bmp" };
		for (int i = 0; i < 6; i++)	// 載入動畫
			walkingLeft.AddBitmap(filename1[i], RGB(0, 0, 0));
		//向右走動畫
		char *filename2[6] = { ".\\bitmaps\\walkingR1.bmp",".\\bitmaps\\walkingR2.bmp",".\\bitmaps\\walkingR3.bmp",".\\bitmaps\\walkingR4.bmp", ".\\bitmaps\\walkingR3.bmp", ".\\bitmaps\\walkingR2.bmp" };
		for (int i = 0; i < 6; i++)	// 載入動畫
			walkingRight.AddBitmap(filename2[i], RGB(0, 0, 0));
		RectHero = heroL.ReturnCRect();
		//E動畫
		char *filenameW[8] = { ".\\bitmaps\\Clock1.bmp",".\\bitmaps\\Clock2.bmp",".\\bitmaps\\Clock3.bmp",".\\bitmaps\\Clock4.bmp", ".\\bitmaps\\Clock5.bmp", ".\\bitmaps\\Clock6.bmp", ".\\bitmaps\\Clock7.bmp", ".\\bitmaps\\Clock8.bmp" };
		for (int i = 0; i < 6; i++)	// 載入動畫
			skillE.AddBitmap(filenameW[i], RGB(0, 0, 0));
		skillE.SetDelayCount(2);
		//普功動畫(左)
		normalAttackL.AddBitmap(IDB_COUNTER1, RGB(0, 0, 0));
		normalAttackL.AddBitmap(IDB_COUNTER2, RGB(0, 0, 0));
		normalAttackL.AddBitmap(IDB_COUNTER3, RGB(0, 0, 0));
		normalAttackL.SetDelayCount(5);
		//普功動畫(右)
		normalAttackR.AddBitmap(IDB_CLOCK1, RGB(0, 0, 0));
		normalAttackR.AddBitmap(IDB_CLOCK2, RGB(0, 0, 0));
		normalAttackR.AddBitmap(IDB_CLOCK3, RGB(0, 0, 0));
		normalAttackR.SetDelayCount(5);
		//Q
		q_attack.loadBitmap();
		//防護罩動畫
		char *filename_protective_cover[4] = { ".\\bitmaps\\protected_cover1.bmp",".\\bitmaps\\protected_cover2.bmp",".\\bitmaps\\protected_cover3.bmp"};
		for (int i = 0; i < 3; i++)	// 載入動畫
			protective_cover.AddBitmap(filename_protective_cover[i], RGB(140, 255, 251));
		protective_cover.SetDelayCount(10);
		//技能R動畫
		char *filename_skillR_L[7] = { ".\\bitmaps\\skill_rL1.bmp",".\\bitmaps\\skill_rL2.bmp",".\\bitmaps\\skill_rL3.bmp",".\\bitmaps\\skill_rL4.bmp" ,".\\bitmaps\\skill_rL5.bmp",".\\bitmaps\\skill_rL6.bmp",".\\bitmaps\\skill_rL7.bmp" };
		for (int i = 0; i < 7; i++)	// 載入動畫
			skillR_L.AddBitmap(filename_skillR_L[i], RGB(255, 255, 255));
		skillR_L.SetDelayCount(3);
		
		char *filename_skillR_R[7] = { ".\\bitmaps\\skill_rR1.bmp",".\\bitmaps\\skill_rR2.bmp",".\\bitmaps\\skill_rR3.bmp",".\\bitmaps\\skill_rR4.bmp" ,".\\bitmaps\\skill_rR5.bmp",".\\bitmaps\\skill_rR6.bmp",".\\bitmaps\\skill_rR7.bmp" };
		for (int i = 0; i < 7; i++)	// 載入動畫
			skillR_R.AddBitmap(filename_skillR_R[i], RGB(255, 255, 255));
		skillR_R.SetDelayCount(3);
	}
	void Hero::OnMove(Maps * m, vector<Enemy*> * enemys) 
	{
		if (!isUsingR) 
		{//如果向要向左，並且下一步是可以走的地方，就會向左走。其他右上下以此類推
			if (isMovingLeft && m->isEmpty(x - HMS, y) && m->isEmpty(x - HMS, GetY2() - 10))
			{
				m->addSX(HMS);
				x -= HMS;
				slide_left = 30;
			}
			if (isMovingRight && m->isEmpty(GetX2() + HMS, y) && m->isEmpty(GetX2() + HMS, GetY2() - 10))
			{
				m->addSX(-HMS);
				x += HMS;
				slide_right = 30;
			}
			if (isMovingUp && m->isEmpty(x + 10, y - HMS) && m->isEmpty(GetX2() - 10, y - HMS))
			{
				m->addSY(HMS);
				y -= HMS;
				slide_up = 30;
			}
			if (isMovingDown && m->isEmpty(x + 10, GetY2() + HMS) && m->isEmpty(GetX2() - 10, GetY2() + HMS))
			{
				m->addSY(-HMS);
				y += HMS;
				slide_down = 30;
			}
			if (m->isOnIce(x + 30, y + 60))
			{							//如果腳的部分踩在冰上面就會滑
				isSlide = true;
			}
			else 
			{
				isSlide = false;
				slide_left = slide_right = slide_down = slide_up = 0;
			}
		}
		if (gonnaBleeding(enemys, GetX1(), GetX2(), GetY1(), GetY2()))
		{
			//hp -= 10;
		}
		m->getHeroX(x);
		m->getHeroY(y);
		walkingLeft.OnMove();
		walkingRight.OnMove();
		skillEMove();					
		skillWMove(m);
		skillQMove(m);
		skillRMove();
		normalAttackMove();
		get_attacked.OnMove();
		if (skillW_shadeShowCount > 0)
		{
			skillW_shadeShowCount -= 1;
		}
		if (isSpeedingUp)
		{					//如果處於加速狀態，跑速增加
			speedUp();
		}
		if (cantBeDamaged)
		{				//如果正在用防護罩，每次防護招的使用期限--
			protectiveCoverCount();
		}
		if (isSlide)
		{
			slide(m);
		}
	}
	void Hero::OnShow(Maps *m)
	{
		blood_bar.setXY(x - 10, y - 10);
		blood_bar.showBloodBar(m, hp);
		gettingAttackedShow();
		skillWShow(m);
		if (isUsingSkill()) 
		{ 
			normalAttackShow(m);
			skillEShow();
			skillQShow(m);
			skillRShow();
		}
		else 
		{
			heroShow(m);
		}
		showHeroStatus();
		showProtectiveCover(m);
	}
	int Hero::GetX1() 
	{
		return x;
	}
	int Hero::GetY1()
	{
		return y;
	}
	int Hero::GetX2()
	{
		return x + heroR.Width();
	}
	int Hero::GetY2()
	{
		return y + heroR.Height();
	}
	int Hero::GetQCoolDown()
	{
		return skill_q_cool_down;
	}
	int Hero::GetWCoolDown()
	{
		return skill_w_cool_down;
	}
	int Hero::GetECoolDown()
	{
		return skill_e_cool_down;
	}
	int Hero::GetRCoolDown()
	{
		return skill_r_cool_down;
	}
	int Hero::getHP()
	{
		return hp;
	}
	int Hero::getFullHP()
	{
		return blood_bar.getFullHP();
	}
	int Hero::get_attack_fire()
	{
		return attack_fire;
	}
	int Hero::get_attack_ice()
	{
		return attack_ice;
	}
	int Hero::get_attack_plant()
	{
		return attack_plant;
	}
	bool Hero::GetIsMovingLeft()
	{
		return isMovingLeft;
	}
	bool Hero::GetIsMovingRight()
	{
		return isMovingRight;
	}
	bool Hero::GetIsMovingUp()
	{
		return isMovingUp;
	}
	bool Hero::GetIsMovingDown()
	{
		return isMovingDown;
	}
	int Hero::GetStepSize()
	{
		return movement_speed;
	}
	ELEMENT_ATTRIBUTE Hero::getCurrentAttribute()
	{
		return _attribute;
	}
	vector<Item*>* Hero::getItemsOfPlayer()
	{
		return &items;
	}
	void Hero::Initialize() 
	{
		x = 480;
		y = 480;
		hp = 1200;
		//attack_fire = SKILL_EVO_TVALUE; //借我測一下flame，晚點改回來。
		attack_fire = 20;
		attack_ice = 20;
		attack_plant = 20;
		skillTimes = 0;
		skillW_shadeShowCount = 0;
		skillW_shadeX = skillW_shadeY = 0;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttack = is_getting_attacked = isSpeedingUp = cantBeDamaged = false;
		isUsingA = isUsingQ = isUsingW = isUsingE = isUsingR = false;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		skill_e_cool_down = skill_q_cool_down = skill_w_cool_down = skill_r_cool_down = 0;
		slide_left = slide_right = slide_down = slide_up = 0;
		item_shoe_clock = item_protective_cover_clock = 0;
		isSlide = false;
		_attribute = FIRE;
		movement_speed = 5;
		for (int i = 0; i < 6; i++)
		{
			items.at(i) = nullptr;
		}
	}
	/////////////////////////////////////////////////////////////////////////////
	void Hero::SetMovingDown(bool b) 
	{
		isMovingDown = b;
		directionUD = 1;
	}
	void Hero::SetMovingUp(bool b) 
	{
		isMovingUp = b;
		directionUD = 0;
	}
	void Hero::SetMovingLeft(bool b)
	{
		isMovingLeft = b;
		directionLR = 0;
	}
	void Hero::SetMovingRight(bool b) 
	{
		isMovingRight = b;
		directionLR = 1;
	}
	void Hero::SetXY(int num_x, int num_y)
	{
		x = num_x;
		y = num_y;
	}
	void Hero::addSX(int n, Maps *m)
	{
		x += n;
		m->addSX(-n);
	}
	void Hero::addSY(int n, Maps * m)
	{
		y += n;
		m->addSY(-n);
	}
	/////////////////////////////////////////////////////////////////////////////
	void Hero::SetUsingA(bool b)
	{
		int random_fx = rand() % 1000;
		if (!isUsingSkill())
		{//偵測到按下A，如果沒有正在使用其他技能
			if (b) 
			{
				CAudio::Instance()->Play(AUDIO_SWORD);
				if (random_fx <= 5)
					CAudio::Instance()->Play(AUDIO_SING);
			}
			isUsingA = b;								//把isUsingA改成b
		}
	}
	void Hero::SetUsingQ(bool b)
	{
		if (!isUsingSkill() && skill_q_cool_down <= 0) 
		{
			skill_q_cool_down = 60;
			if (b) 
			{
				skillQ();
			}
			isUsingQ = b;
		}
	}
	void Hero::SetUsingW(bool b)
	{
		if (!isUsingSkill() && skill_w_cool_down <= 0) 
		{		//如果沒再用其他技能，且w技能的冷卻時間以冷卻完成，才可以把isUsingW設為true
			skill_w_cool_down = 180;
			isUsingW = b;
		}
	}
	void Hero::SetUsingE(bool b)
	{
		if (!isUsingSkill() && skill_e_cool_down <= 0)
		{
			skill_e_cool_down = 150;
			if (b)
			{
				CAudio::Instance()->Play(AUDIO_BEGGER);
				CAudio::Instance()->Play(AUDIO_SKILLE);
			}
			isUsingE = b;
		}
	}
	void Hero::SetUsingR(bool b)
	{
		if (!isUsingSkill() && skill_r_cool_down <= 0)
		{
			skill_r_cool_down = 900; //如果正式遊戲應該要900(久一點)
			int random_fx = rand() % 2;
			if (b) 
			{
				if (random_fx == 0)
					CAudio::Instance()->Play(AUDIO_SKILLR_1);
				if (random_fx == 1)
					CAudio::Instance()->Play(AUDIO_SKILLR_2);
			}
			isUsingR = b;
		}
	}
	void Hero::SetElementAttribute(ELEMENT_ATTRIBUTE e)
	{
		_attribute = e;
	}
	void Hero::SetAllCoolDownToZero()			//讓所有技能冷卻時間重製為0
	{
		skill_q_cool_down = skill_e_cool_down = skill_w_cool_down = skill_r_cool_down = 0;
	}
	/////////////////////////////////////////////////////////////////////////////
	bool Hero::gonnaBleeding(vector<Enemy*> * enemys, int x1, int x2, int y1, int y2)
	{
		int attack = 0;
		if (_attribute == FIRE)
		{//如果現在屬性是火屬性的，攻擊力就等於火屬性的攻擊力
			attack = -1*attack_fire;
		}
		if (_attribute == ICE)
		{//如果現在屬性是冰屬性的，攻擊力就等於冰屬性的攻擊力
			attack = -1*attack_ice;
		}
		if (_attribute == PLANT) 
		{//如果現在屬性是草屬性的，攻擊力就等於草屬性的攻擊力
			attack = -1*attack_plant;
		}
		for (unsigned i = 0; i < enemys->size(); i++)
		{
			//普功，如果跟普功的範圍有相交，enemy就會扣血
			if (enemys->at(i)->intersect(x1 - 30, x2 - 30, y1 + 10, y2) && directionLR == 0 && isUsingA)
			{
				enemys->at(i)->offsetHP(attack, _attribute);
			}
			if (enemys->at(i)->intersect(x1 + 30, x2 + 30, y1 + 10, y2) && directionLR == 1 && isUsingA)
			{
				enemys->at(i)->offsetHP(attack, _attribute);
			}
			//Q技能	  如果跟技能的範圍有相交，enemy就會扣血
			if (enemys->at(i)->intersect(q_attack.getX1(), q_attack.getX2(), q_attack.getY1(), q_attack.getY2()) && isUsingQ)
			{
				if (attack_fire >= SKILL_EVO_TVALUE && _attribute == FIRE)
				{//如果火屬性攻擊力超過升級標準，就會變成進化的攻擊技能
					enemys->at(i)->offsetHP(attack * 2, _attribute);
				}
				else if (attack_plant >= SKILL_EVO_TVALUE && _attribute == PLANT) 
				{
					enemys->at(i)->offsetHP(attack/2, _attribute);
					enemys->at(i)->knockBack();
					enemys->at(i)->knockBack();
				}
				else 
				{
					enemys->at(i)->offsetHP(attack, _attribute);
				}
			}
			//E技能
			if (enemys->at(i)->intersect(x1 - 30, x2 + 30, y1 - 30, y2 + 30) && isUsingE)
			{
				enemys->at(i)->offsetHP(attack, _attribute);
			}
			//R技能
			if (enemys->at(i)->distanceToHero() < 80 && isUsingR )
			{
				if (skillR_R.GetCurrentBitmapNumber() == 5 || skillR_L.GetCurrentBitmapNumber() == 5) 
				{
					if (enemys->at(i)->hpProportion() <= 0.6) 
					{
						enemys->at(i)->offsetHP(-10000, _attribute);
					}
				}
			}
		}
		return false;
	}
	void Hero::offsetHp(int n)
	{
		int rand_being_attacked_fx = rand() % 100;
		if (!cantBeDamaged) 
		{
			//有40%的機率發出被攻擊的哭喊(如果一直叫會太吵)
			if (rand_being_attacked_fx <= 40)
				CAudio::Instance()->Play(AUDIO_BEING_ATTACKED);
			is_getting_attacked = true;
			hp -= n;
		}
	}
	void Hero::addHp(int n)
	{
		hp += n;
	}
	void Hero::addAttack(int n, ELEMENT_ATTRIBUTE attribute)
	{
		if (attribute == FIRE) 
		{
			attack_fire += n;
		}
		if (attribute == ICE)
		{
			attack_ice += n;
		}
		if (attribute == PLANT)
		{
			attack_plant += n;
		}
	}
	void Hero::addItem(Item * item)
	{
		int n = -1;
		for (int i = 5; i >= 0; i--) 
		{
			if (items.at(i) == nullptr)
			{
				n = i;
			}
		}
		if (n != -1 && items.at(n) == nullptr) 
		{
			items.at(n) = item;
		}
		else
		{
			delete item;
		}
	}
	void Hero::cleanItems()
	{
		for (vector<Item*>::iterator it_i = items.begin(); it_i != items.end(); ++it_i) 
		{
			delete *it_i;
		}
	}
	void Hero::slide(Maps * m)
	{
		if (slide_right > 0) 
		{
			slide_right--;
		}
		if (slide_left > 0)
		{
			slide_left--;
		}
		if (slide_up > 0) 
		{
			slide_up--;
		}
		if (slide_down > 0)
		{
			slide_down--;
		}
		if (!isMovingLeft && m->isEmpty(x - HMS, y) && m->isEmpty(x - HMS, GetY2() - 10))
		{
			if (slide_left > 0)
			{
				m->addSX((int)(slide_left/5.0));
				x -= (int)(slide_left / 5.0);
				if (isMovingRight) 
				{
					m->addSX(HMS);
					x -= HMS;
				}
			}
		}
		if (!isMovingRight && m->isEmpty(GetX2() + HMS, y) && m->isEmpty(GetX2() + HMS, GetY2() - 10))
		{
			if (slide_right > 0)
			{
				m->addSX(-(int)(slide_right / 5.0));
				x += (int)(slide_right / 5.0);
				if (isMovingLeft) 
				{
					m->addSX(-HMS);
					x += HMS;
				}
			}
		}
		if (!isMovingUp && m->isEmpty(x + 10, y - HMS) && m->isEmpty(GetX2() - 10, y - HMS))
		{
			if (slide_up > 0)
			{
				m->addSY((int)(slide_up / 5.0));
				y -= (int)(slide_up / 5.0);
				if(isMovingDown)
				{
					m->addSY(HMS);
					y -= HMS;
				}
			}
		}
		if (!isMovingDown && m->isEmpty(x + 10, GetY2() + HMS) && m->isEmpty(GetX2() - 10, GetY2() + HMS))
		{
			if (slide_down > 0) 
			{
				m->addSY(-(int)(slide_down / 5.0));
				y += (int)(slide_down / 5.0);
				if (isMovingUp) 
				{
					m->addSY(-HMS);
					y += HMS;
				}
			}
		}
	}
	void Hero::speedUp()
	{
		if (item_shoe_clock > 0) 
		{
			item_shoe_clock--;
			movement_speed = 10;
			if (item_shoe_clock == 0)
			{
				movement_speed = 5;
				isSpeedingUp = false;
			}
		}
	}
	void Hero::setSpeedUp(bool b)
	{
		if (b) 
		{
			CAudio::Instance()->Play(AUDIO_SHOE);
			item_shoe_clock = 90;
			isSpeedingUp = true;
		}
	}
	void Hero::protectiveCoverCount()
	{
		if (item_protective_cover_clock > 0) 
		{
			protective_cover.OnMove();
			item_protective_cover_clock--;
			if (item_protective_cover_clock == 0) 
			{
				cantBeDamaged = false;
			}
		}
		else 
		{
			protective_cover.Reset();
		}
	}
	void Hero::setCantBeDamaged(bool b)
	{
		if (b) 
		{
			cantBeDamaged = true;
			item_protective_cover_clock = 90;
		}
	}
	void Hero::showProtectiveCover(Maps * m)
	{
		protective_cover.SetTopLeft(260, 270);
		if (cantBeDamaged)
		{
			protective_cover.OnShow();
		}
	}
	/////////////////////////////////////////////////////////////////////////////
	bool Hero::isMoving()
	{
		if (isMovingDown || isMovingLeft || isMovingRight || isMovingUp)
		{
			return true;
		}
		else 
		{
			return false;
		}
	}
	bool Hero::isAlive()
	{
		if (hp > 0) 
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool Hero::isInFinishArea(Maps * m)
	{
		if (m->inFinishArea(x, y))
		{
			return true;
		}
		else 
		{
			return false;
		}
	}
	bool Hero::isUsingSkill()
	{
		if (isUsingA || isUsingQ || isUsingE || isUsingR)
		{
			return true;
		}
		return false;
	}
	void Hero::heroShow(Maps *m)
	{
		if (directionLR == 0)
		{
			if (isMoving())
			{
				walkingLeft.SetTopLeft(m->screenX(x), m->screenY(y));
				walkingLeft.OnShow();
			}
			else 
			{
				heroL.SetTopLeft(m->screenX(x), m->screenY(y));
				heroL.ShowBitmap();
			}

		}
		else
		{
			if (isMoving()) 
			{
				walkingRight.SetTopLeft(m->screenX(x), m->screenY(y));
				walkingRight.OnShow();
			}
			else
			{
				heroR.SetTopLeft(m->screenX(x), m->screenY(y));
				heroR.ShowBitmap();
			}
		}
	}
	bool Hero::intercect(int x1, int x2, int y1, int y2)
	{
		if (x2 >= x + 20 && x1 <= x + walkingRight.Width() && y2 >= y && y1 <= y + walkingRight.Height()) 
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	/////////////////////////////////////////////////////////////////////////////
	void Hero::normalAttackMove()
	{
		normalAttackL.OnMove();
		normalAttackR.OnMove();
		if (!isUsingA)
		{
			normalAttackL.Reset();			//沒有用技能的時候 要Reset CAnimation，下次才會從第一張圖跑
			normalAttackR.Reset();
		}
	}
	void Hero::normalAttackShow(Maps *m)
	{
		if (directionLR == 0 && isUsingA)
		{
			normalAttackL.SetTopLeft(m->screenX(x) - 20, m->screenY(y) - 10);
			normalAttackL.OnShow();
			if (normalAttackL.IsFinalBitmap())
			{
				isUsingA = false;
			}
		}
		if (directionLR == 1 && isUsingA)
		{
			normalAttackR.SetTopLeft(m->screenX(x) - 20, m->screenY(y) - 10);
			normalAttackR.OnShow();
			if (normalAttackR.IsFinalBitmap())
			{
				isUsingA = false;
			}
		}
	}
	void Hero::showHeroStatus()
	{
		CDC *pDC = CDDraw::GetBackCDC();			// 取得 Back Plain 的 CDC 
		CFont f, *fp;
		f.CreatePointFont(160, "Times New Roman");	// 產生 font f; 160表示16 point的字
		fp = pDC->SelectObject(&f);					// 選用 font f
		pDC->SetBkColor(RGB(0, 0, 0));
		pDC->SetTextColor(RGB(255, 255, 0));
		char str[80];								// Demo 數字對字串的轉換
		sprintf(str,"Cool Down: Q:%d  E:%d  R:%d  HP: %d", skill_q_cool_down / 30,skill_e_cool_down / 30, skill_r_cool_down / 30, hp);
		pDC->TextOut(0, 0, str);
		pDC->SelectObject(fp);						// 放掉 font f (千萬不要漏了放掉)
		CDDraw::ReleaseBackCDC();					// 放掉 Back Plain 的 CDC
	}
	void Hero::gettingAttackedShow()
	{
		if (is_getting_attacked) {
			get_attacked.SetTopLeft(0, 0);
			get_attacked.OnShow();
			if (get_attacked.IsFinalBitmap()) 
			{
				is_getting_attacked = false;
			}
		}
		else 
		{
			get_attacked.Reset();
		}
	}
	void Hero::skillQ()
	{
		if (!isUsingSkill()) 
		{
			q_attack.setXY(x, y);
			if (_attribute == FIRE) 
			{
				CAudio::Instance()->Play(AUDIO_FIRE);
			}
			if (_attribute == ICE) 
			{
				CAudio::Instance()->Play(AUDIO_ICE);
			}
			if (_attribute == PLANT)
			{
				CAudio::Instance()->Play(AUDIO_GRASSBALL);
			}
			q_attack.setAttackIsFlying(true);
			if (directionLR == 0)
			{
				q_attack.setDirection(0);
				q_attack.setStepSize(-10, 0);
			}
			if (directionLR == 1)
			{
				q_attack.setDirection(1);
				q_attack.setStepSize(10, 0);
			}
		}
	}
	void Hero::skillQMove(Maps *m)
	{
		if (isUsingQ) 
		{
			q_attack.OnMove(m);
			q_attack.setXY(x, y);
		}
		if (skill_q_cool_down > 0)
		{
			skill_q_cool_down -= 1;
		}
		if (_attribute == FIRE)
		{
			q_attack.setAttackName(FIRE_BALL);
			if (!isUsingQ)
			{
				q_attack.resetAnimation(FIRE_BALL);
			}
			if (attack_fire >= SKILL_EVO_TVALUE) 
			{
				q_attack.setAttackName(FIRE_FLAME);
				if (!isUsingQ)
				{
					q_attack.resetAnimation(FIRE_FLAME);
				}
			}
		}
		if (_attribute == ICE) 
		{
			q_attack.setAttackName(ICE_BALL);
			if (!isUsingQ)
			{
				q_attack.resetAnimation(ICE_BALL);
			}
		}
		if (_attribute == PLANT)
		{
			q_attack.setAttackName(GRASS_BALL);
			if (!isUsingQ)
			{
				q_attack.resetAnimation(GRASS_BALL);
			}
			if (attack_plant >= SKILL_EVO_TVALUE)
			{
				q_attack.setAttackName(GRASS_TORNADO);
				if (!isUsingQ)
				{
					q_attack.resetAnimation(GRASS_TORNADO);
				}
			}
		}
	}
	void Hero::skillQShow(Maps * m)
	{
		if (isUsingQ)
		{
			heroShow(m);
			q_attack.OnShow(m);
			skillTimes += 1;							//+1代表跑了1/30秒
			if (skillTimes > 20) 
			{						//預計讓他飛2/3秒
				isUsingQ = false;
				q_attack.setAttackIsFlying(false);
				skillTimes = 0;							//跑完整個技能把skillTime設回為0
			}
		}
	}
	void Hero::useItem(int n)
	{
		if (items.at(n - 1) != nullptr) 
		{
			items.at(n - 1)->effect(this);
		}
		vector<Item*>::iterator it_i = items.begin();
		for (int i = 0; i < n - 1; i++)
		{
			++it_i;
		}
		delete *it_i;
		items.at(n - 1) = nullptr;
	}
	void Hero::setShadePosition()
	{
		skillW_shadeX = x;
		skillW_shadeY = y;
	}
	void Hero::skillWMove(Maps *m)
	{
		if (skill_w_cool_down > 0)
		{
			skill_w_cool_down -= 1;
		}

		if (isUsingW)
		{
			skillW_shadeShowCount = 10;
			if (isMovingLeft)
			{
				if (m->isEmpty(x - 15 * HMS, y) && m->isEmpty(x - 15 * HMS, GetY2() - 10) && m->isEmpty(x - 30 * HMS, y) && m->isEmpty(x - 30 * HMS, GetY2() - 10))
				{
					CAudio::Instance()->Play(AUDIO_GOODFLASH);
					m->addSX(32 * HMS);
					x -= 32 * HMS;
				}
				else
				{
					CAudio::Instance()->Play(AUDIO_BADFLASH);
				}
			}
			if (isMovingRight)
			{
				if (m->isEmpty(GetX2() + 15 * HMS, y) && m->isEmpty(GetX2() + 15 * HMS, GetY2() - 10) && m->isEmpty(GetX2() + 30 * HMS, y) && m->isEmpty(GetX2() + 30 * HMS, GetY2() - 10))
				{
					CAudio::Instance()->Play(AUDIO_GOODFLASH);
					m->addSX(-32 * HMS);
					x += 32 * HMS;
				}
				else
				{
					CAudio::Instance()->Play(AUDIO_BADFLASH);
				}
			}
			if (isMovingUp)
			{
				if (m->isEmpty(x + 10, y - 15 * HMS) && m->isEmpty(GetX2() - 10, y - 15 * HMS) && m->isEmpty(x + 10, y - 30 * HMS) && m->isEmpty(GetX2() - 10, y - 30 * HMS))
				{
					CAudio::Instance()->Play(AUDIO_GOODFLASH);
					m->addSY(32 * HMS);
					y -= 32 * HMS;
				}
				else
				{
					CAudio::Instance()->Play(AUDIO_BADFLASH);
				}
			}
			if (isMovingDown)
			{
				if (m->isEmpty(x + 10, GetY2() + 15 * HMS) && m->isEmpty(GetX2() - 10, GetY2() + 15 * HMS) && m->isEmpty(x + 10, GetY2() + 30 * HMS) && m->isEmpty(GetX2() - 10, GetY2() + 30 * HMS))
				{
					m->addSY(-32 * HMS);
					y += 32 * HMS;
				}
				else
				{
					CAudio::Instance()->Play(AUDIO_BADFLASH);
				}
			}
		}
		isUsingW = false;
	}
	void Hero::skillWShow(Maps *m)
	{
		if (skillW_shadeShowCount > 0)
		{
			if (directionLR == 0)
			{
				shadeL.SetTopLeft(m->screenX(skillW_shadeX), m->screenY(skillW_shadeY));
				shadeL.ShowBitmap();
			}
			if (directionLR == 1)
			{
				shadeR.SetTopLeft(m->screenX(skillW_shadeX), m->screenY(skillW_shadeY));
				shadeR.ShowBitmap();
			}
		}
	}
	void Hero::skillEMove()
	{
		if (skill_e_cool_down > 0) {
			skill_e_cool_down -= 1;
		}
		skillE.OnMove();
		if (!isUsingE)
			skillE.Reset(); 
	}
	void Hero::skillEShow()
	{
		if (isUsingE)
		{
			skillE.SetTopLeft(280 - 25, 280 - 15);
			skillE.OnShow();
			if (skillE.IsFinalBitmap()) 
			{
				skillTimes += 1;			//+1代表跑了一回CAnimation
				if (skillTimes == 3) 
				{
					skillTimes = 0;			//跑完整個技能把skillTime設回為0
					isUsingE = false;
				}
			}
		}
	}
	void Hero::skillRMove()
	{
		if (skill_r_cool_down > 0)
		{
			skill_r_cool_down -= 1;
		}

		if (directionLR == 0)
		{
			skillR_L.OnMove();
		}
		else {
			skillR_R.OnMove();
		}
		if (!isUsingR) 
		{
			skillR_L.Reset();
			skillR_R.Reset();
		}
	}
	void Hero::skillRShow()
	{
		if (isUsingR) 
		{
			if (directionLR == 0) 
			{
				skillR_L.SetTopLeft(280 - 25, 280 - 215);
				skillR_L.OnShow();
			}
			else 
			{
				skillR_R.SetTopLeft(280 + 25, 280 - 215);
				skillR_R.OnShow();
			}
			if (skillR_L.IsFinalBitmap()) 
			{
				isUsingR = false;
			}
			if (skillR_R.IsFinalBitmap())
			{
				isUsingR = false;
			}
		}
	}
}

Hero.h
#ifndef HERO_H
#define HERO_H
#include "Util.h"
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
#include "Attack.h"
#include "Item.h"
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供玩家操控的hero											   //
	/////////////////////////////////////////////////////////////////////////////
	class Enemy;
	class Item;
	class Hero :public Character
	{
	public:
		Hero();
		~Hero();
		void LoadBitmap();
		void OnShow(Maps *m) override;
		void OnMove(Maps *m, vector<Enemy*> * enemys);
		int GetX1();					//回傳最左側X值
		int GetY1();					//回傳最上側Y值
		int GetX2();					//回傳最右側X值
		int GetY2();					//回傳最下側Y值
		int GetQCoolDown();				//回傳冷卻時間
		int GetWCoolDown();
		int GetECoolDown();
		int GetRCoolDown();
		int getHP();					//回傳HP
		int getFullHP();				//回傳滿血狀態的HP
		int get_attack_fire();			//回傳火屬性的攻擊力
		int get_attack_ice();
		int get_attack_plant();
		bool GetIsMovingLeft();			//回傳是否在移動
		bool GetIsMovingRight();
		bool GetIsMovingUp();
		bool GetIsMovingDown();
		int GetStepSize();				//回傳每次移動的距離
		ELEMENT_ATTRIBUTE getCurrentAttribute();		//回傳現在的屬性
		vector<Item *> * getItemsOfPlayer();			//回傳道具欄的VECTOR
		void Initialize();
		/////////////////////////////////////////////////////////////////////////////
		// 設定Hero的座標的函式們													   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);
		void SetMovingUp(bool b);
		void SetMovingLeft(bool b);
		void SetMovingRight(bool b);
		void SetXY(int num_x, int num_y);
		void addSX(int n, Maps *m);
		void addSY(int n, Maps *m);
		/////////////////////////////////////////////////////////////////////////////
		// 設定Hero使用技能的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetUsingA(bool b);
		void SetUsingQ(bool b);
		void SetUsingW(bool b);
		void SetUsingE(bool b);
		void SetUsingR(bool b);
		void SetElementAttribute(ELEMENT_ATTRIBUTE e);
		void SetAllCoolDownToZero();
		/////////////////////////////////////////////////////////////////////////////
		// 前身是cantPass，應該是本程式最重要的函式之一								   //
		// 1. 角色碰到敵人會扣血													   //
		// 2. 如果敵人在攻擊範圍內，且在攻擊狀態下，敵人會被扣血						   //
		/////////////////////////////////////////////////////////////////////////////
		bool gonnaBleeding(vector<Enemy*> * enemys, int x1, int x2, int y1, int y2);
		void offsetHp(int n);
		void addHp(int n);
		void addAttack(int n, ELEMENT_ATTRIBUTE attribute);
		void addItem(Item * item);
		void cleanItems();
		void slide(Maps *m);
		////////////////////用道具的
		void speedUp();
		void setSpeedUp(bool b);
		void protectiveCoverCount();
		void setCantBeDamaged(bool b);
		void showProtectiveCover(Maps *m);
		/////////////////////////////////////////////////////////////////////////////
		bool isMoving();					// 在動
		bool isAlive();
		bool isInFinishArea(Maps *m);
		bool isUsingSkill();			// 如果在用技能，return true	
		void heroShow(Maps *m);
		bool intercect(int x1, int x2, int y1, int y2);
		/////////////////////////////////////////////////////////////////////////////
		void normalAttackMove();		// 普功的Move
		void normalAttackShow(Maps *m);		// 普功的Show
		void showHeroStatus();			//顯示hp 技能冷卻時間
		void gettingAttackedShow();
		/////////////////////////////////////////////////////////////////////////////
		void skillQ(); 
		void skillQMove(Maps *m);
		void skillQShow(Maps *m);
		void useItem(int n);
		void setShadePosition();
		void skillWMove(Maps *m);
		void skillWShow(Maps *m);
		void skillEMove();
		void skillEShow();
		void skillRMove();
		void skillRShow();
		/////////////////////////////////////////////////////////////////////////////
	private:
		CMovingBitmap heroL, heroR;
		CMovingBitmap shadeL, shadeR;
		CAnimation walkingLeft;
		CAnimation walkingRight;
		CAnimation skillE;
		CAnimation skillR_L;
		CAnimation skillR_R;
		CAnimation normalAttackL; // 向左普功動畫
		CAnimation normalAttackR; // 向右普功動畫
		CAnimation get_attacked;
		CAnimation protective_cover;
		BloodBar blood_bar;
		CRect RectHero;
		int x, y;
		int hp;
		int attack_fire;				//三種屬性的攻擊力
		int attack_ice;
		int attack_plant;
		ELEMENT_ATTRIBUTE _attribute;	//英雄現在的屬性
		vector<Item *> items;			//存放道具欄裡面道具的vector
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttack;
		bool isUsingA;
		bool isUsingQ;
		bool isUsingW;
		bool isUsingE;
		bool isUsingR;
		bool is_getting_attacked;
		int status;
		bool directionLR;				// 0為左 1為右
		bool directionUD;				// 0為上 1為下
		int skillTimes;					// 用來數跑了幾次CAnimation。
		Attack q_attack;
		///冷卻時間
		int skill_q_cool_down;			//cool down在每個skill的move function裡每秒-30
		int skill_w_cool_down;
		int skill_e_cool_down;
		int skill_r_cool_down;			
		//滑起來
		int slide_right, slide_left, slide_up, slide_down;
		bool isSlide;
		//道具造成狀態
		int item_shoe_clock;
		bool isSpeedingUp;
		bool cantBeDamaged;
		int item_protective_cover_clock;
		int skillW_shadeX;						//閃現前原本的X座標
		int skillW_shadeY;						//閃現前原本的Y座標
		unsigned int skillW_shadeShowCount;
	};
}
#endif

IceBird.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Arrow.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "IceBird.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework
{
	//若在Character和Enemy中都有一個hp，選擇直接用Character中的那個
	IceBird::IceBird()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	IceBird::IceBird(int x, int y, Hero *h) : Enemy(x, y, 70000, "IceBird", h, ICE)
	{
		attack_damage = 20;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));
	}
	IceBird::~IceBird()
	{
	}
	void IceBird::LoadBitmap()
	{
		icewallLeft.LoadBitmap(".\\bitmaps\\icewallL1.bmp", RGB(255, 255, 255));
		icewallRight.LoadBitmap(".\\bitmaps\\icewallR1.bmp", RGB(255, 255, 255));
		boss_blood_bar.loadBloodBar();
		/////掉落道具
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->load();
		}
		/////怪物的動畫
		char *filename1_1[10] = { ".\\bitmaps\\icebirdL1.bmp",".\\bitmaps\\icebirdL2.bmp",".\\bitmaps\\icebirdL3.bmp", ".\\bitmaps\\icebirdL4.bmp",  ".\\bitmaps\\icebirdL5.bmp",  ".\\bitmaps\\icebirdL6.bmp",  ".\\bitmaps\\icebirdL7.bmp",  ".\\bitmaps\\icebirdL8.bmp",  ".\\bitmaps\\icebirdL9.bmp",  ".\\bitmaps\\icebirdL10.bmp" };
		for (int i = 0; i < 10; i++)	// 載入動畫
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		walkingLeft.SetDelayCount(3);
		char *filename1_2[10] = { ".\\bitmaps\\icebirdR1.bmp",".\\bitmaps\\icebirdR2.bmp",".\\bitmaps\\icebirdR3.bmp", ".\\bitmaps\\icebirdR4.bmp",  ".\\bitmaps\\icebirdR5.bmp",  ".\\bitmaps\\icebirdR6.bmp",  ".\\bitmaps\\icebirdR7.bmp",  ".\\bitmaps\\icebirdR8.bmp",  ".\\bitmaps\\icebirdR9.bmp",  ".\\bitmaps\\icebirdR10.bmp" };
		for (int i = 0; i < 10; i++)	// 載入動畫
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		walkingRight.SetDelayCount(3);
		/////攻擊的動畫
		char *filename2_1[10] = { ".\\bitmaps\\icebirdL1.bmp",".\\bitmaps\\icebirdL2.bmp",".\\bitmaps\\icebirdL3.bmp", ".\\bitmaps\\icebirdL4.bmp",  ".\\bitmaps\\icebirdL5.bmp",  ".\\bitmaps\\icebirdL6.bmp",  ".\\bitmaps\\icebirdL7.bmp",  ".\\bitmaps\\icebirdL8.bmp",  ".\\bitmaps\\icebirdL9.bmp",  ".\\bitmaps\\icebirdL10.bmp" };
		for (int i = 0; i < 10; i++)	// 載入動畫
			normalAttackL.AddBitmap(filename2_1[i], RGB(0, 0, 0));
		normalAttackL.SetDelayCount(1);
		char *filename2_2[10] = { ".\\bitmaps\\icebirdR1.bmp",".\\bitmaps\\icebirdR2.bmp",".\\bitmaps\\icebirdR3.bmp", ".\\bitmaps\\icebirdR4.bmp",  ".\\bitmaps\\icebirdR5.bmp",  ".\\bitmaps\\icebirdR6.bmp",  ".\\bitmaps\\icebirdR7.bmp",  ".\\bitmaps\\icebirdR8.bmp",  ".\\bitmaps\\icebirdR9.bmp",  ".\\bitmaps\\icebirdR10.bmp" };
		for (int i = 0; i < 10; i++)	// 載入動畫
			normalAttackR.AddBitmap(filename2_2[i], RGB(0, 0, 0));
		normalAttackR.SetDelayCount(1);
		/////冰牆的動畫
		char *filename_wallL[8] = { ".\\bitmaps\\icewallL1.bmp",".\\bitmaps\\icewallL2.bmp",".\\bitmaps\\icewallL3.bmp",".\\bitmaps\\icewallL4.bmp",".\\bitmaps\\icewallL5.bmp",".\\bitmaps\\icewallL6.bmp",".\\bitmaps\\icewallL7.bmp",".\\bitmaps\\icewallL8.bmp", };
		for (int i = 0; i < 8; i++)	// 載入動畫
			icewallL.AddBitmap(filename_wallL[i], RGB(255, 255, 255));
		icewallL.SetDelayCount(5);
		char *filename_wallR[8] = { ".\\bitmaps\\icewallR1.bmp",".\\bitmaps\\icewallR2.bmp",".\\bitmaps\\icewallR3.bmp",".\\bitmaps\\icewallR4.bmp",".\\bitmaps\\icewallR5.bmp",".\\bitmaps\\icewallR6.bmp",".\\bitmaps\\icewallR7.bmp",".\\bitmaps\\icewallR8.bmp",};
		for (int i = 0; i < 8; i++)	// 載入動畫
			icewallR.AddBitmap(filename_wallR[i], RGB(255, 255, 255));
		icewallR.SetDelayCount(5);
		ice_attack.loadBitmap();
		////暴風雪的動畫
		char *filename_storm[6] = { ".\\bitmaps\\storm1.bmp",".\\bitmaps\\storm2.bmp",".\\bitmaps\\storm3.bmp",".\\bitmaps\\storm4.bmp",".\\bitmaps\\storm5.bmp",".\\bitmaps\\storm6.bmp"};
		for (int i = 0; i < 6; i++)	// 載入動畫
			storm.AddBitmap(filename_storm[i], RGB(255, 255, 255));
	}
	void IceBird::OnMove(Maps * m) 
	{
		const int STEP_SIZE = 4;
		if (isAlive())
		{
			attack_cool_down -= 1;
			walkingLeft.OnMove();
			walkingRight.OnMove();
			normalAttackL.OnMove();
			normalAttackR.OnMove();
			movement(m);
			iceAttack();
			iceAttackMove(m);
			iceWall(m);
			iceStorm(m);
			iceStormMove(m);
			if (arrowAttackCD != 0)
			{
				arrowAttackCD--;
			}
		}
		iceWallMove(m);
		if (!isAlive())
		{
			isUsingIceWall = false;
			//如果冰鳥死掉，過門時回頭主角對冰鳥開噴
			CAudio::Instance()->Play(AUDIO_ICEBIRD_DIE);
			itemsOnMove(m);
		}
	}
	void IceBird::OnShow(Maps *m)
	{
		if (isAlive()) 
		{
			iceStormShow(m);
			if (_direction == 0)
			{
				iceWallShow(m);
				if (isAttacking)
				{
					boss_blood_bar.setXY(GetX1(), GetY1()-16);
					boss_blood_bar.showBloodBar(m, hp - 16);
					iceAttackShow(m);
				}
				else
				{
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					boss_blood_bar.setXY(GetX1(), GetY1()-16);
					boss_blood_bar.showBloodBar(m, hp);
				}
			}
			else
			{
				iceWallShow(m);
				if (isAttacking) 
				{
					boss_blood_bar.setXY(GetX1(), GetY1()-16);
					boss_blood_bar.showBloodBar(m, hp);
					iceAttackShow(m);
				}
				else 
				{
					boss_blood_bar.setXY(GetX1(), GetY1()-16);
					boss_blood_bar.showBloodBar(m, hp);
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
				}
			}
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int IceBird::GetX1()
	{
		return _x;
	}
	int IceBird::GetY1()
	{
		return _y;
	}
	int IceBird::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int IceBird::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void IceBird::Initialize() 
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking = attackIsFlying = isUsingIceWall = isUsingStorm = false;
		hp = 70000;
		arrorClock = 0;
		arrowAttackCD = 180;
		ice_wall_clock = 0;
		ice_wall_cd = 180;
		storm_clock = 0;
		storm_cd = 240;
		 boss_blood_bar.setFullHP(hp);
		///道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->Initialize();
		}
		ice_attack.setAttackName(ICE_BALL);
	}
	bool IceBird::intersect(int x1, int x2, int y1, int y2)
	{
		//下面有一些加減運算是因為，Bitmap本身比身體大太多。
		if (isAlive()) 
		{
			if (x2 >= _x + 80  && x1 <= _x + walkingRight.Width() - 80 && y2 >= _y  && y1 <= _y + walkingRight.Height() ) {
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	int IceBird::distanceToHero()
	{
		int x = (GetX1() + GetX2()) / 2;
		int y = (GetY1() + GetY2()) / 2;
		int x_distance = x - hero_on_map->GetX1();
		int y_distance = y - hero_on_map->GetY1();
		return (int)(sqrt(pow(x_distance, 2) + pow(y_distance, 2)));
	}
	void IceBird::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void IceBird::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void IceBird::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void IceBird::SetMovingRight(bool b)
	{
		isMovingRight = b;
	}
	void IceBird::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void IceBird::movement(Maps *m)
	{
		int x = (GetX1() + GetX2())/2;
		int y = (GetY1() + GetY2())/2;
		if (x > hero_on_map->GetX1())
		{
			_direction = 0;
		}
		else if(x - 4 < hero_on_map->GetX1())
		{
			_direction = 1;
		}
		int step_size = 3;
		if (distanceToHero() < 500 && distanceToHero() > 180)
		{
			if (hero_on_map->GetX1() > x )
			{
				_x += step_size;
			}
			if (hero_on_map->GetX1() < x )
			{
				_x -= step_size;
			}
			if (hero_on_map->GetY1() > y )
			{
				_y += step_size;
			}
			if (hero_on_map->GetY1() < y )
			{
				_y -= step_size;
			}
		}
	}
	void IceBird::attack()
	{
	}
	void IceBird::attackShow(Maps * m)
	{
		if (isAttacking) 
		{
			normalAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
			normalAttackR.OnShow();
			if (normalAttackR.IsFinalBitmap()) 
			{
				isAttacking = false;
				attack_cool_down = 90; //每次攻擊間隔3秒
			}
		}
	}
	void IceBird::iceAttack()
	{
		if (!isAttacking && arrowAttackCD == 0)
		{
			int x = (GetX1() + GetX2()) / 2;
			int y = (GetY1() + GetY2()) / 2;
			ice_attack.setXY(x, y);
			if (distanceToHero() <= 180) 
			{
				int x = (GetX1() + GetX2()) / 2;
				int y = (GetY1() + GetY2()) / 2;
				double x_distance =  hero_on_map->GetX1() - x;
				double y_distance =  hero_on_map->GetY1() - y;
				int ice_step_size_x = (int)(10 * x_distance / distanceToHero());
				int ice_step_size_y = (int)(10 * y_distance / distanceToHero());
				arrorClock = 60;
				ice_attack.setAttackIsFlying(true);
				ice_attack.setStepSize(ice_step_size_x, ice_step_size_y);
				isAttacking = true;
				arrowAttackCD = 180;
			}
		}
	}
	void IceBird::iceAttackMove(Maps * m)
	{
		if (isAttacking) 
		{
			if (hero_on_map->intercect(ice_attack.getX1(), ice_attack.getX2(), ice_attack.getY1(), ice_attack.getY2())) 
			{
				hero_on_map->offsetHp(attack_damage);
			}
		}
		if (isAttacking && arrorClock != 0) 
		{
			arrorClock--;
			if (arrorClock == 0)
			{
				isAttacking = false;
				ice_attack.setAttackIsFlying(false);
			}
		}
		ice_attack.OnMove(m);
	}
	void IceBird::iceAttackShow(Maps * m)
	{
		if (isAttacking)
		{
			if (_direction == 0)
			{
				normalAttackL.SetTopLeft(m->screenX(_x), m->screenY(_y));
				normalAttackL.OnShow();
				ice_attack.OnShow(m);
			}
			if (_direction == 1)
			{
				normalAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
				normalAttackR.OnShow();;
				ice_attack.OnShow(m);
			}
		}
	}
	void IceBird::iceWall(Maps *m)
	{
		if (!isUsingIceWall &&ice_wall_cd == 0) 
		{
			icewall_direction = _direction;
			if (icewall_direction == 0)
			{
				ice_wall_x = ((hero_on_map->GetX1() - 36) / 64) * 64;
				ice_wall_y = ((_y-100) / 64) * 64;
				isUsingIceWall = true;
				ice_wall_clock = 180;
				for (int i = 0; i < 7; i++)
				{
					m->setIceWallPos(ice_wall_x, ice_wall_y + (64 * i), 1);
				}
			}
			if (icewall_direction == 1) 
			{
				ice_wall_x = ((hero_on_map->GetX1() + 100) / 64) * 64;
				ice_wall_y = ((_y - 100) / 64) * 64;
				isUsingIceWall = true;
				ice_wall_clock = 180;
				for (int i = 0; i < 7; i++)
				{
					m->setIceWallPos(ice_wall_x, ice_wall_y + (64 * i), 1);
				}
			}
		}
	}
	void IceBird::iceWallMove(Maps * m)
	{
		
		if (ice_wall_clock > 0 && isUsingIceWall) 
		{
			ice_wall_clock--;
			if (ice_wall_clock <= 40 && ice_wall_clock >=0 )
			{
				if (icewall_direction == 0 && !icewallL.IsFinalBitmap())
				{
					icewallL.OnMove();
				}
				if (icewall_direction == 1 && ! icewallR.IsFinalBitmap())
				{
					icewallR.OnMove();
				}
			}
			if (ice_wall_clock == 0)
			{
				isUsingIceWall = false;
				icewallL.Reset();
				icewallR.Reset();
				ice_wall_cd = 180;
			}
			if (!isAlive())
			{
				isUsingIceWall = false;
			}
			if (!isUsingIceWall)
			{
				for (int i = 0; i < 7; i++)
				{
					m->setIceWallPos(ice_wall_x, ice_wall_y + (64 * i), -1);
				}
			}
		}
		if (ice_wall_cd > 0) 
		{
			ice_wall_cd--;
		}
	}
	void IceBird::iceWallShow(Maps * m)
	{
		if (isUsingIceWall)
		{
			if (ice_wall_clock > 40 && ice_wall_clock <= 180)
			{
				if (icewall_direction == 0)
				{
					icewallLeft.SetTopLeft(m->screenX(ice_wall_x)-80, m->screenY(ice_wall_y));
					icewallLeft.ShowBitmap();
				}
				if (icewall_direction == 1)
				{
					icewallRight.SetTopLeft(m->screenX(ice_wall_x), m->screenY(ice_wall_y));
					icewallRight.ShowBitmap();
				}
			}
			if (ice_wall_clock <= 40 && ice_wall_clock >=0)
			{
				if (icewall_direction == 0)
				{
					icewallL.SetTopLeft(m->screenX(ice_wall_x)-80, m->screenY(ice_wall_y));
					icewallL.OnShow();
				}
				if(icewall_direction)
				{
					icewallR.SetTopLeft(m->screenX(ice_wall_x), m->screenY(ice_wall_y));
					icewallR.OnShow();
				}
			}
		}
	}
	void IceBird::iceStorm(Maps * m)
	{
		if (!isUsingStorm && storm_cd == 0)
		{	
			storm_x = hero_on_map->GetX1();
			storm_y = hero_on_map->GetY2();
			storm_x -= 120;
			storm_y -= 130;
			isUsingStorm = true;
			storm_clock = 120;
		}
	}
	void IceBird::iceStormMove(Maps * m)
	{
		if (storm_clock > 0)
		{
			storm_clock--;
			storm.OnMove();
			if (storm_clock == 0)
			{
				isUsingStorm = false;
				storm.Reset();
				storm_cd = 240;
			}
		}
		if (storm_cd > 0) 
		{
			storm_cd--;
		}
		if (isUsingStorm) 
		{
			if (intersectStorm(hero_on_map->GetX1(), hero_on_map->GetX2(), hero_on_map->GetY1(), hero_on_map->GetY2())) {
				if (hero_on_map->GetIsMovingLeft())
				{
					hero_on_map->addSX(2, m);
				}
				if (hero_on_map->GetIsMovingRight())
				{
					hero_on_map->addSX(-2, m);
				}
				if (hero_on_map->GetIsMovingUp())
				{
					hero_on_map->addSY(2, m);
				}
				if (hero_on_map->GetIsMovingDown())
				{
					hero_on_map->addSY(-2, m);
				}
				if (storm_clock % 5 == 1) 
				{
					hero_on_map->offsetHp(5);
				}
			}
		}
	}
	void IceBird::iceStormShow(Maps * m)
	{
		if (isUsingStorm) 
		{
			storm.SetTopLeft(m->screenX(storm_x), m->screenY(storm_y));
			storm.OnShow();
		}
	}
	bool IceBird::intersectStorm(int x1, int x2, int y1, int y2)
	{
		if (isUsingStorm) 
		{
			if (x2 >= storm_x + 50 && x1 <= storm_x + storm.Width() - 50 && y2 >= storm_y + 100 && y1 <= storm_y + storm.Height() - 100) {
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
}
IceBird.h
#ifndef ICEBIRD_H
#define ICEBIRD_H

#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
#include "Arrow.h"
#include "BossBloodBar.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個敵人													   //
	// 第二關的Boss		 													   //
	/////////////////////////////////////////////////////////////////////////////
	class Arrow;
	class IceBird :public Enemy
	{
	public:
		IceBird();						//建構子，傳給Character角色名稱
		IceBird(int x, int y, Hero *h);	//建構子，設定角色初始位置給Character()，方便vector一次建立
		~IceBird();
		void LoadBitmap();						//加載敵人Bitmap
		void OnShow(Maps *m) override;			//顯示敵人於畫面上
		void OnMove(Maps *m);					//敵人移動
		int GetX1();							//回傳最左側X值
		int GetY1();							//回傳最上側Y值
		int GetX2();							//回傳最右側X值
		int GetY2();							//回傳最下側Y值
		void Initialize()override;				//初始化
		//英雄是否和此敵人所在同一位置，前身是cannotPass
		bool intersect(int x1, int x2, int y1, int y2) override;
		int distanceToHero();
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);					//下
		void SetMovingUp(bool b);					//上
		void SetMovingLeft(bool b);					//左
		void SetMovingRight(bool b);				//右
		void SetXY(int x, int y);					//x, y座標
		void movement(Maps *m);
		//用來攻擊的
		void attack();
		void attackShow(Maps *m);
		void iceAttack();
		void iceAttackMove(Maps *m);
		void iceAttackShow(Maps *m);
		//冰牆
		void iceWall(Maps *m);
		void iceWallMove(Maps *m);
		void iceWallShow(Maps *m);
		//暴風雪
		void iceStorm(Maps *m);
		void iceStormMove(Maps *m);
		void iceStormShow(Maps *m);
		bool intersectStorm(int x1, int x2, int y1, int y2);
	private:
		BossBloodBar boss_blood_bar;
		CMovingBitmap arrowAttackL;
		CMovingBitmap arrowAttackR;
		CMovingBitmap icewall;
		CMovingBitmap icewallLeft;
		CMovingBitmap icewallRight;
		CAnimation walkingLeft;
		CAnimation walkingRight;
		CAnimation normalAttackL;
		CAnimation normalAttackR;
		CAnimation icewallL;
		CAnimation icewallR;
		CAnimation storm;
		Arrow arr;
		Attack ice_attack;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		bool isUsingIceWall;
		bool attackIsFlying;
		int attack_cool_down;
		int move_or_not;
		int time_bump_into_sth;
		bool icewall_direction;
		//招式的cd
		int arrowAttackCD;
		int arrorClock;
		//冰牆
		int ice_wall_clock;
		int ice_wall_x, ice_wall_y;
		int ice_wall_cd;
		//暴風雪
		int storm_clock;
		int storm_x, storm_y;
		int storm_cd;
		bool isUsingStorm;
	};
}
#endif 
Item.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
namespace game_framework
{
	Item::Item()
	{
	}
	void Item::showOnStatusBar(int n)
	{
		if (n < 3) 
		{												//前三個道具顯示在道具欄的上面三個
			item_on_status_bar.SetTopLeft(540 + (n % 3) * 30, 0);
		}
		if (n >= 3)
		{												//4-6顯示在下面三個
			item_on_status_bar.SetTopLeft(540 + (n % 3) * 30, 30);
		}
		item_on_status_bar.ShowBitmap();
	}
	void Item::Initialize()
	{
		_isExist = true;
		random_num = rand();
		_isUsed = false;
	}
	bool Item::isExist()
	{
		return _isExist;
	}
	void Item::setExist(bool b)
	{
		_isExist = b;
	}
	void Item::setNumOfBox(int n)
	{
		num_of_box = n;
	}
	void Item::setXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void Item::setRandomNum(int n)
	{
		random_num = n;
	}
	int Item::getX()
	{
		return _x;
	}
	int Item::getY()
	{
		return _y;
	}
	int Item::getRandomNum()
	{
		return random_num;
	}
	int Item::getNumOfBox()
	{
		return num_of_box;
	}
	bool Item::intercect(Hero * h)
	{
		if (isExist())
		{
			if (h->GetX2() >= _x+10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		return false;
	}
	bool Item::getIsUsed()
	{
		return _isUsed;
	}
	void Item::setIsUsed(bool b)
	{
		_isUsed = b;
	}
}

Item.h
#ifndef __ITEM_H
#define __ITEM_H
#include "Maps.h"
#include "Hero.h"
#include "Character.h"
namespace game_framework 
{
	class Hero;
	class Item
	{
	public:
		Item();
		virtual void load() = 0;
		virtual void OnMove(Maps *m, Hero *h) = 0;
		virtual void OnShow(Maps *m) = 0;
		virtual void effect(Hero *h) = 0;
		void showOnStatusBar(int n);					//顯示道具圖片在上面的道具欄裡面
		void Initialize();
		bool isExist();									//return _isExist
		void setExist(bool b);							//設定 _isExist
		void setNumOfBox(int n);						//設定num_of_box
		void setXY(int x, int y);						//設定XY座標
		void setRandomNum(int n);						//設定random_num
		int getX();										//得到x座標
		int getY();										//得到Y座標
		int getRandomNum();								//return random_num
		int getNumOfBox();								//return num_of_box
		bool intercect(Hero *h);						//偵測是否跟別的物件座標位置相交
		bool getIsUsed();								//return _isUsed
		void setIsUsed(bool b);							//設定_isUsed
	private:
		int _x, _y;										// XY座標
		bool _isExist;									//是否存在
		int random_num;									//一個隨機數
		bool _isUsed;									//是否被使用了
		int num_of_box;									//一個隨機數，用來判定道具箱會掉哪個道具
<<<<<<< HEAD

=======
>>>>>>> b21484bf4faa30161cb87177111bbcf0ee7ce529
	protected:
		CMovingBitmap item_on_status_bar;
	};
}
#endif
ItemAttribute.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "Health.h"
#include "ItemAttribute.h"
#include "Util.h"
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// ItemAttribute: Item class											   //
	/////////////////////////////////////////////////////////////////////////////
	ItemAttribute::ItemAttribute(ELEMENT_ATTRIBUTE attribute)
	{
		_attribute = attribute;									
	}
	void ItemAttribute::load()
	{
		fire_pic.LoadBitmap(IDB_ATTRIBUTEFIRE, RGB(0, 0, 0));
		ice_pic.LoadBitmap(IDB_ATTRIBUTEICE, RGB(0, 0, 0));
		plant_pic.LoadBitmap(IDB_ATTRIBUTEPLANT, RGB(0, 0, 0));
	}
	void ItemAttribute::OnMove(Maps *m, Hero *h)
	{
		_x = getX();
		_y = getY() + 30;
		if (isExist() && intercect(h))
		{//如果intercest hero的屬性會變成這個掉落物的屬性
			h->SetElementAttribute(_attribute);
			h->addAttack(1, _attribute);					//hero 這個屬性的攻擊力會+1
			setExist(false);
		}
	}
	void ItemAttribute::OnShow(Maps *m)						//看不同屬性 顯示不同的圖片
	{
		if (isExist())
		{	
			if (_attribute == FIRE)
			{						
				fire_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
				fire_pic.ShowBitmap();
			}
			if (_attribute == ICE)
			{
				ice_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
				ice_pic.ShowBitmap();
			}
			if (_attribute == PLANT)
			{
				plant_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
				plant_pic.ShowBitmap();
			}
		}
	}
	bool ItemAttribute::intercect(Hero * h)
	{
		if(isExist())
		{
			if (h->GetX2() >= _x + 10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	void ItemAttribute::effect(Hero *h)
	{
	}
}

ItemAttribute.h
#ifndef __ITEMATTRIBUTE_H
#define __ITEMATTRIBUTE_H
#include "Maps.h"
#include "Character.h"
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具 : 屬性點數增加										   //
	// 道具可由箱子或擊殺怪物獲得												   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class ItemAttribute: public Item					//這class是掉落物 是屬性 怪死掉會 掉落
	{
	public:
		ItemAttribute(ELEMENT_ATTRIBUTE attribute);		
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		bool intercect(Hero *h) ;						//檢測是否相交
		void effect(Hero *h);	
	private:
		CMovingBitmap fire_pic;
		CMovingBitmap ice_pic;
		CMovingBitmap plant_pic;
		ELEMENT_ATTRIBUTE _attribute;					//掉落物的屬性
		int _x, _y;
	};
}
#endif
Map1_1.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include <vector>
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// Map1_1: Maps class													   //
	/////////////////////////////////////////////////////////////////////////////
	Map1_1::Map1_1():Maps(-200, -200) 
	{//0為空 1為障礙物 3為可以前往下一關的區域 5為滑滑的地方
		all_enemy_clear = 0;
		for (int i = 0; i < 12; i++)
		{
			for (int j = 0; j < 12; j++) {
				if ((i > 0 && i < 11) && ((j >= 0 && j <= 3) || j == 11)) 
				{
					map[i][j] = 1;
				}
				else if ((i == 0 || i == 11) && (j > 0 && j < 12))
				{
					map[i][j] = 1;
				}
				else
				{
					map[i][j] = 0;
				}
			}
		}
		map[5][2] = map[6][2] = 3;
		map[5][3] = map[6][3] = 0;
		map[1][4] = map[2][4] =  map[9][4] = map[1][5] = map[10][5] = 1;
		map[1][9] = map[1][10] = map[2][10] =  map[10][9] = map[9][10] = map[10][10] = 1;
	}
	Map1_1::~Map1_1()
	{
	}
	void Map1_1::Initialize()
	{
		setXY(-200, -200);
	}
	void Map1_1::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map1_1::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map1_1::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1)
		{
			return true;
		}
		return false;
	}
	bool Map1_1::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3)
		{
			return true;
		}
		return false;
	}
	bool Map1_1::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5)
		{
			return true;
		}
		return false;
	}
	void Map1_1::OnMove() 
	{
	}
	void Map1_1::LoadBitmap()
	{
		firstmap.LoadBitmap(IDB_MAP1_1);
		char *filename1_1[4] = { ".\\bitmaps\\gate1.bmp",".\\bitmaps\\gate2.bmp",".\\bitmaps\\gate3.bmp",".\\bitmaps\\gate4.bmp" };
		for (int i = 0; i < 4; i++)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map1_1::OnShow() 
	{
		firstmap.SetTopLeft(getSX(),getSY());
		firstmap.ShowBitmap();
		if(all_enemy_clear ==1)
		{
			gate.SetTopLeft(getSX()+320, getSY()+64);
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map1_1::getHeroX(int x)
	{
		hx = x;
	}
	void Map1_1::getHeroY(int y)
	{
		hy = y;
	}
	int Map1_1::screenX(int x)
	{
		return x + getSX();
	}
	int Map1_1::screenY(int y)
	{
		return y + getSY();
	}
	void Map1_1::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map1_1.h
#include "Enemy.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供地圖														   //
	/////////////////////////////////////////////////////////////////////////////
	class Map1_1 : public Maps
	{
	public:
		Map1_1();
		~Map1_1();
		void Initialize();
		void setPos(int x, int y, int n);			//將地圖座標的陣列設為傳入的數字
		void setClear(bool b);
		bool isEmpty(int x, int y) const;			//檢查是否為可以走的地方
		bool inFinishArea(int x, int y) override;	//是否在可以前往下一關的地方
		bool isOnIce(int x, int y);					//是否在冰上面
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;				//把絕對座標換成螢幕的做鰾
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);	//設定icewall
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[12][12];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map1_2.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map1_2.h"
#include <vector>

namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map1_2::Map1_2():Maps(-200, -200) 
	{
		all_enemy_clear = 0;
		for (int i = 0; i < 16; i++)
		{
			for (int j = 0; j < 13; j++) 
			{
				if (i > 0 && i < 15 && j >= 2 && j <= 11)
				{
					map[i][j] = 0;
				}
				else 
				{
					map[i][j] = 1;
				}
			}
		}
		map[7][1] = map[8][1] = 3;
		map[1][5] = map[2][4] = map[3][3] = map[12][3] = map[13][4] = map[14][5] = 1;
		map[1][2] = map[1][3] = map[2][2] = map[13][2] = map[14][2] = map[14][3] = 1;
		map[1][11] = map[1][10] = map[2][11] = map[14][10] = map[13][11] = map[14][11] = 1;
	}
	Map1_2::~Map1_2()
	{
	}
	void Map1_2::Initialize()
	{
		setXY(-200, -200);
	}
	void Map1_2::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map1_2::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map1_2::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1)
		{
			return true;
		}
		return false;
	}
	bool Map1_2::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3)
		{
			return true;
		}
		return false;
	}
	bool Map1_2::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5)
		{
			return true;
		}
		return false;
	}
	void Map1_2::OnMove()
	{
	}
	void Map1_2::LoadBitmap()
	{
		firstmap.LoadBitmap(IDB_MAP1_2);
		char *filename1_1[4] = { ".\\bitmaps\\gate1.bmp",".\\bitmaps\\gate2.bmp",".\\bitmaps\\gate3.bmp",".\\bitmaps\\gate4.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map1_2::OnShow() 
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX()+448, getSY());
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map1_2::getHeroX(int x)
	{
		hx = x;
	}
	void Map1_2::getHeroY(int y)
	{
		hy = y;
	}
	int Map1_2::screenX(int x)
	{
		return x + getSX();
	}
	int Map1_2::screenY(int y)
	{
		return y + getSY();
	}
	void Map1_2::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map1_2.h
#include "Enemy.h"
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	class Map1_2 : public Maps
	{
	public:
		Map1_2();
		~Map1_2();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b) override;
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[15][12];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map1_3.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map1_3.h"
#include <vector>
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map1_3::Map1_3():Maps(-200, -200)
	{
		all_enemy_clear = 0;
		for (int i = 0; i < 18; i++)
		{
			for (int j = 0; j < 15; j++) {
				if (i > 1 && i < 16 && j > 2 && j < 13) 
				{
					map[i][j] = 0;
				}
				else 
				{
					map[i][j] = 1;
				}
			}
		}
		map[2][3] = map[2][12] = map[15][3] = map[15][12] = 1;
		map[6][9] = map[7][8] = map[10][9] = map[11][8] = 1;
		map[8][2] = map[9][2] = 3;
	}
	Map1_3::~Map1_3()
	{
	}
	void Map1_3::Initialize()
	{
		setXY(-200, -200);
	}
	void Map1_3::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map1_3::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map1_3::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1)
		{
			return true;
		}
		return false;
	}
	bool Map1_3::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3) 
		{
			return true;
		}
		return false;
	}
	bool Map1_3::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5)
		{
			return true;
		}
		return false;
	}
	void Map1_3::OnMove()
	{
	}
	void Map1_3::LoadBitmap()
	{
		firstmap.LoadBitmap(IDB_MAP1_3);
		char *filename1_1[4] = { ".\\bitmaps\\gate1.bmp",".\\bitmaps\\gate2.bmp",".\\bitmaps\\gate3.bmp",".\\bitmaps\\gate4.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map1_3::OnShow()
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX()+512, getSY()+64);
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map1_3::getHeroX(int x)
	{
		hx = x;
	}
	void Map1_3::getHeroY(int y)
	{
		hy = y;
	}
	int Map1_3::screenX(int x)
	{
		return x + getSX();
	}
	int Map1_3::screenY(int y)
	{
		return y + getSY();
	}
	void Map1_3::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map1_3.h
#include "Enemy.h"
namespace game_framework
{
	class Map1_3 : public Maps
	{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	public:
		Map1_3();
		~Map1_3();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b) override;
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[15][18];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map1_4.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map1_4.h"
#include <vector>

namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map1_4::Map1_4():Maps(-500, -1190) {
		for (int i = 0; i < 25; i++) {
			for (int j = 0; j < 25; j++) {
				if (i > 2 && i < 22 && j >= 3 && j < 22) {
					map[i][j] = 0;
				}
				else {
					map[i][j] = 1;
				}
			}
		}
		map[9][10] = map[15][10] = map[9][16] = map[15][16] = 1;
		for (int i = 10; i <= 14; i++) {
			map[i][1] = 0;
			map[i][2] = 0;
			map[i][22] = 0;
			map[i][23] = 0;
		}
		map[9][22] = map[15][22] = map[9][2] = map[15][2] = 0;
		for (int i = 10; i <= 14; i++) {
			map[1][i] = 0;
			map[2][i] = 0;
			map[22][i] = 0;
			map[23][i] = 0;
		}
		map[2][9] = map[22][9] = map[2][15] = map[22][15] = 0;
		map[12][1] = map[11][1] = 3;
	}
	Map1_4::~Map1_4()
	{
	}
	void Map1_4::Initialize()
	{
		setXY(-500, -1190);
	}
	void Map1_4::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map1_4::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map1_4::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1) {
			return true;
		}
		return false;
	}
	bool Map1_4::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3) {
			return true;
		}
		return false;
	}
	bool Map1_4::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5) {
			return true;
		}
		return false;
	}
	void Map1_4::OnMove()
	{
	}
	void Map1_4::LoadBitmap()
	{
		firstmap.LoadBitmap(IDB_MAP1_4);
		char *filename1_1[4] = { ".\\bitmaps\\gate1.bmp",".\\bitmaps\\gate2.bmp",".\\bitmaps\\gate3.bmp",".\\bitmaps\\gate4.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map1_4::OnShow()
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX() + 512, getSY() + 64);
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map1_4::getHeroX(int x)
	{
		hx = x;
	}
	void Map1_4::getHeroY(int y)
	{
		hy = y;
	}
	int Map1_4::screenX(int x)
	{
		return x + getSX();
	}
	int Map1_4::screenY(int y)
	{
		return y + getSY();
	}
	void Map1_4::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map1_4.h
#include "Enemy.h"
namespace game_framework
{
	class Map1_4 : public Maps
	{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	public:
		Map1_4();
		~Map1_4();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b);
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[25][25];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map2_1.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map2_1.h"
#include <vector>
namespace game_framework
{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map2_1::Map2_1():Maps(-200, -200)
	{
		all_enemy_clear = 0;
		for (int i = 0; i < 18; i++) 
		{
			for (int j = 0; j < 15; j++)
			{
				if (i > 1 && i < 16 && j > 2 && j < 13)
				{
					map[i][j] = 0;
				}
				else
				{
					map[i][j] = 1;
				}
			}
		}
		map[8][9] = map[9][9] = 1;
		map[2][3] = map[2][4] = map[3][3] =  map[2][12] = map[15][12] = map[14][3] =  map[15][3] = map[15][4] = 1;
		map[8][2] = map[9][2] = 3;
		map[5][6] = map[5][7] = map[5][11] = map[5][12] = map[4][6] = map[4][7] = map[4][11] = map[4][12] = 5;
		map[12][5] = map[12][6] = map[12][10] = map[12][11] = map[13][5] = map[13][6] = map[13][10] = map[13][11] = 5;
	}
	Map2_1::~Map2_1()
	{
	}
	void Map2_1::Initialize()
	{
		setXY(-200, -200);
	}
	void Map2_1::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map2_1::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map2_1::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1)
		{
			return true;
		}
		return false;
	}
	bool Map2_1::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3)
		{
			return true;
		}
		return false;
	}
	bool Map2_1::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5) 
		{
			return true;
		}
		return false;
	}
	void Map2_1::OnMove() 
	{
	}
	void Map2_1::LoadBitmap() 
	{
		firstmap.LoadBitmap(IDB_MAP2_1);
		char *filename1_1[4] = { ".\\bitmaps\\gate5.bmp",".\\bitmaps\\gate6.bmp",".\\bitmaps\\gate7.bmp",".\\bitmaps\\gate8.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map2_1::OnShow() 
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX()+512, getSY() + 64);
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map2_1::getHeroX(int x)
	{
		hx = x;
	}
	void Map2_1::getHeroY(int y)
	{
		hy = y;
	}
	int Map2_1::screenX(int x)
	{
		return x + getSX();
	}
	int Map2_1::screenY(int y)
	{
		return y + getSY();
	}
	void Map2_1::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map2_1.h
#include "Enemy.h"
namespace game_framework
{
	class Map2_1 : public Maps
	{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	public:
		Map2_1();
		~Map2_1();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b) override;
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[18][15];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map2_2.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map2_2.h"
#include <vector>
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map2_2::Map2_2():Maps(-200, -200) 
	{
		all_enemy_clear = 0;
		for (int i = 0; i < 18; i++)
		{
			for (int j = 0; j < 16; j++) 
			{
				if (i > 1 && i < 16 && j > 1 && j < 14)
				{
					map[i][j] = 0;
				}
				else
				{
					map[i][j] = 1;
				}
			}
		}
		map[2][2] = map[2][3] = map[3][2] =  map[2][13] = map[15][13] = map[14][2] =  map[15][2] = map[15][3] = 1;
		map[8][1] = map[9][1] = 3;
		//設定冰
		for (int i = 6; i < 12; i++) 
		{
			for (int j = 5; j < 11; j++)
			{
				map[i][j] = 5;
			}
		}
	}
	Map2_2::~Map2_2()
	{
	}
	void Map2_2::Initialize()
	{
		setXY(-200, -200);
	}
	void Map2_2::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map2_2::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map2_2::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1) 
		{
			return true;
		}
		return false;
	}
	bool Map2_2::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3) 
		{
			return true;
		}
		return false;
	}
	bool Map2_2::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5) 
		{
			return true;
		}
		return false;
	}
	void Map2_2::OnMove()
	{
	}
	void Map2_2::LoadBitmap() 
	{
		firstmap.LoadBitmap(IDB_MAP2_2);
		char *filename1_1[4] = { ".\\bitmaps\\gate5.bmp",".\\bitmaps\\gate6.bmp",".\\bitmaps\\gate7.bmp",".\\bitmaps\\gate8.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map2_2::OnShow()
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX()+512, getSY());
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map2_2::getHeroX(int x)
	{
		hx = x;
	}
	void Map2_2::getHeroY(int y)
	{
		hy = y;
	}
	int Map2_2::screenX(int x)
	{
		return x + getSX();
	}
	int Map2_2::screenY(int y)
	{
		return y + getSY();
	}
	void Map2_2::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map2_2.h
#include "Enemy.h"
namespace game_framework {
	class Map2_2 : public Maps
	{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	public:
		Map2_2();
		~Map2_2();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b) override;
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[18][16];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map2_3.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map2_3.h"
#include <vector>
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map2_3::Map2_3():Maps(-200, -200) 
	{
		all_enemy_clear = 0;
		for (int i = 0; i < 24; i++) 
		{
			for (int j = 0; j < 19; j++) 
			{
				if (i > 1 && i < 22 && j > 2 && j < 17)
				{
					map[i][j] = 0;
				}
				else 
				{
					map[i][j] = 1;
				}
			}
		}
		map[11][2] = map[12][2] = 3;
		map[2][3] = map[2][16] = map[21][3] = map[21][16] = 1;
		map[7][5] = map[7][6] = map[4][9] = map[4][10] = map[7][13] = map[7][14] = map[16][5] = map[16][6] = map[16][14] = map[16][13] = map[19][9] = map[19][10] = 1;
		for (int i = 9; i < 15; i++) 
		{
			for (int j = 8; j < 14; j++)
			{
				map[i][j] = 5;
			}
		}
		map[11][10] = map[12][10] = 1;
		map[11][11] = map[12][11] = 0;
	}
	Map2_3::~Map2_3()
	{
	}
	void Map2_3::Initialize()
	{
		setXY(-200, -200);
	}
	void Map2_3::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map2_3::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map2_3::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1 && map[gx][gy] != 2) 
		{
			return true;
		}
		return false;
	}
	bool Map2_3::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3)
		{
			return true;
		}
		return false;
	}
	bool Map2_3::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5)
		{
			return true;
		}
		return false;
	}
	void Map2_3::OnMove() 
	{
	}
	void Map2_3::LoadBitmap()
	{
		firstmap.LoadBitmap(IDB_MAP2_3);
		char *filename1_1[4] = { ".\\bitmaps\\gate5.bmp",".\\bitmaps\\gate6.bmp",".\\bitmaps\\gate7.bmp",".\\bitmaps\\gate8.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map2_3::OnShow() 
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX()+704, getSY()+64);
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map2_3::getHeroX(int x)
	{
		hx = x;
	}
	void Map2_3::getHeroY(int y)
	{
		hy = y;
	}
	int Map2_3::screenX(int x)
	{
		return x + getSX();
	}
	int Map2_3::screenY(int y)
	{
		return y + getSY();
	}
	void Map2_3::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map2_3.h
#include "Enemy.h"
namespace game_framework {
	class Map2_3 : public Maps
	{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	public:
		Map2_3();
		~Map2_3();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b) override;
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[24][19];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Map2_4.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map2_4.h"
#include <vector>
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.cpp														   //
	/////////////////////////////////////////////////////////////////////////////
	Map2_4::Map2_4():Maps(-200, -200)
	{
		all_enemy_clear = 0;
		for (int i = 0; i < 24; i++)
		{
			for (int j = 0; j < 18; j++) 
			{
				if (i > 4 && i < 19 && j > 2 && j < 15)
				{
					map[i][j] = 0;
				}
				else 
				{
					map[i][j] = 1;
				}
			}
		}
		for (int j = 3; j < 15; j++)
		{
			if (j != 6 && j != 7 && j!= 10 && j != 11) 
			{
				map[7][j] = 1;
				map[16][j] = 1;
			}
		}
		map[11][2] = map[12][2] = 3;
	}
	Map2_4::~Map2_4()
	{
	}
	void Map2_4::Initialize()
	{
		setXY(-200, -200);
	}
	void Map2_4::setPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] = n;
	}
	void Map2_4::setClear(bool b)
	{
		all_enemy_clear = b;
	}
	bool Map2_4::isEmpty(int x, int y) const
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] != 1 && map[gx][gy] != 2) 
		{
			return true;
		}
		return false;
	}
	bool Map2_4::inFinishArea(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 3) 
		{
			return true;
		}
		return false;
	}
	bool Map2_4::isOnIce(int x, int y)
	{
		int gx = x / 64;
		int gy = y / 64;
		if (map[gx][gy] == 5) 
		{
			return true;
		}
		return false;
	}
	void Map2_4::OnMove() 
	{
	}
	void Map2_4::LoadBitmap() 
	{
		firstmap.LoadBitmap(IDB_MAP2_4);
		char *filename1_1[4] = { ".\\bitmaps\\gate5.bmp",".\\bitmaps\\gate6.bmp",".\\bitmaps\\gate7.bmp",".\\bitmaps\\gate8.bmp" };
		for (int i = 0; i < 4; i++)	// 載入動畫(由6張圖形構成)
			gate.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		gate.SetDelayCount(3);
	}
	void Map2_4::OnShow()
	{
		firstmap.SetTopLeft(getSX(), getSY());
		firstmap.ShowBitmap();
		if (all_enemy_clear == 1)
		{
			gate.SetTopLeft(getSX()+704, getSY());
			gate.OnMove();
			gate.OnShow();
		}
	}
	void Map2_4::getHeroX(int x)
	{
		hx = x;
	}
	void Map2_4::getHeroY(int y)
	{
		hy = y;
	}
	int Map2_4::screenX(int x)
	{
		return x + getSX();
	}
	int Map2_4::screenY(int y)
	{
		return y + getSY();
	}
	void Map2_4::setIceWallPos(int x, int y, int n)
	{
		int gx = x / 64;
		int gy = y / 64;
		map[gx][gy] += n;
	}
}
Map2_4.h
#include "Enemy.h"
namespace game_framework {
	class Map2_4 : public Maps
	{
	/////////////////////////////////////////////////////////////////////////////
	// 請參考Map1_1.h														   //
	/////////////////////////////////////////////////////////////////////////////
	public:
		Map2_4();
		~Map2_4();
		void Initialize();
		void setPos(int x, int y, int n);
		void setClear(bool b) override;
		bool isEmpty(int x, int y) const;
		bool inFinishArea(int x, int y) override;
		bool isOnIce(int x, int y);
		void OnMove();
		void LoadBitmap();
		void OnShow();
		void getHeroX(int x) override;
		void getHeroY(int y) override;
		int screenX(int x) override;
		int screenY(int y) override;
		void setIceWallPos(int x, int y, int n);
	private:
		CMovingBitmap firstmap;
		CAnimation gate;
		bool all_enemy_clear;
		int map[24][18];
		int hx, hy;
		int stage_left, stage_top;
	};
}
Maps.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Enemy.h"
#include "Map1_4.h"
#include <vector>
namespace game_framework 
{
	Maps::Maps(int x, int y)
	{
		_sx = x;
		_sy = y;
	}
	void Maps::addSX(int n)			//sx+=n 就是地圖向左移動n
	{
		_sx += n;
	}
	void Maps::addSY(int n)			//sx+=n 就是地圖上移動n
	{
		_sy += n;
	}
	void Maps::setXY(int x, int y)
	{
		_sx = x;
		_sy = y;
	}
	int Maps::getSX()
	{
		return _sx;
	}
	int Maps::getSY()
	{
		return _sy;
	}
}
Maps.h
#ifndef __MAPS_H__
#define __MAPS_H__
#include <vector>
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class是Maps的共同介面    											   //
	/////////////////////////////////////////////////////////////////////////////
	class Maps
	{
	public:
		Maps(int x, int y);
		virtual bool isEmpty(int x, int y) const = 0;
		virtual void addSX(int n);
		virtual void addSY(int n);
		virtual int screenX(int x) { return 0; };
		virtual int screenY(int y) { return 0; };
		virtual void getHeroX(int x) {};
		virtual void getHeroY(int y) {};
		virtual void setPos(int x, int y, int n) = 0;
		virtual void setIceWallPos(int x, int y, int n) = 0; // n = +1士冰牆放出時 n = -1冰牆解除的時候
		virtual void setClear(bool b) = 0;
		virtual bool inFinishArea(int x, int y) = 0;
		virtual bool isOnIce(int x, int y) = 0;
		void setXY(int x, int y);
		int getSX();
		int getSY();
	private:
		int _sx, _sy;
		bool all_enemy_clear;
	};
}
#endif
PlayerStatus.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "PlayerStatus.h"
#include "Util.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// CBall: An status/cooldown showing panel								   //
	/////////////////////////////////////////////////////////////////////////////
	PlayerStatus::PlayerStatus()
	{
		_x = 0;
		_y = 0;
	}
	void PlayerStatus::Initialize(Hero * h)
	{
		_h = h;
	}
	void PlayerStatus::loadPlayerStatus() {
		status_bar.LoadBitmap(IDB_STATUSBAR, RGB(255, 255, 255));
		skill_q_fire_pic.LoadBitmap(IDB_SKILLQFIREPIC);
		skill_q_ice_pic.LoadBitmap(IDB_SKILLQICEPIC);
		skill_q_plant_pic.LoadBitmap(IDB_SKILLQPLANTPIC);
		skill_e_pic.LoadBitmap(IDB_SKILLEPIC);
		skill_w_pic.LoadBitmap(IDB_SKILLWPIC);
		skill_r_pic.LoadBitmap(".\\bitmaps\\DariusExecute.bmp");
		loadDigitsBitmap(Q_cooldown_first);
		loadDigitsBitmap(Q_cooldown_ten);
		loadDigitsBitmap(W_cooldown_first);
		loadDigitsBitmap(W_cooldown_ten);
		loadDigitsBitmap(E_cooldown_first);
		loadDigitsBitmap(E_cooldown_ten);
		loadDigitsBitmap(R_cooldown_first);
		loadDigitsBitmap(R_cooldown_ten);
		loadDigitsBitmap(HP_first);
		loadDigitsBitmap(HP_ten);
		loadDigitsBitmap(HP_hundred);
		loadDigitsBitmap(HP_thousand);
		loadDigitsBitmap(attack_fire_first);
		loadDigitsBitmap(attack_fire_ten);
		loadDigitsBitmap(attack_fire_hundred);
		loadDigitsBitmap(attack_fire_thousand);
		loadDigitsBitmap(attack_ice_first);
		loadDigitsBitmap(attack_ice_ten);
		loadDigitsBitmap(attack_ice_hundred);
		loadDigitsBitmap(attack_ice_thousand);
		loadDigitsBitmap(attack_plant_first);
		loadDigitsBitmap(attack_plant_ten);
		loadDigitsBitmap(attack_plant_hundred);
		loadDigitsBitmap(attack_plant_thousand);
	}
	void PlayerStatus::showPlayerStatus()
	{
		status_bar.SetTopLeft(0, 0);
		status_bar.ShowBitmap();
		showQ();
		showE();
		showW();
		showR();
		showHP();
		showAttackFire();
		showAttackIce();
		showAttackPlant();
		showItemsOfPlayer();
	}
	void PlayerStatus::setXY(int x, int y) 
	{
		_x = x;
		_y = y;
	}
	void PlayerStatus::loadDigitsBitmap(CMovingBitmap a[])
	{
		a[0].LoadBitmap(IDB_0 , RGB(0, 0, 0));
		a[1].LoadBitmap(IDB_1, RGB(0, 0, 0));
		a[2].LoadBitmap(IDB_2, RGB(0, 0, 0));
		a[3].LoadBitmap(IDB_3, RGB(0, 0, 0));
		a[4].LoadBitmap(IDB_4, RGB(0, 0, 0));
		a[5].LoadBitmap(IDB_5, RGB(0, 0, 0));
		a[6].LoadBitmap(IDB_6, RGB(0, 0, 0));
		a[7].LoadBitmap(IDB_7, RGB(0, 0, 0));
		a[8].LoadBitmap(IDB_8, RGB(0, 0, 0));
		a[9].LoadBitmap(IDB_9, RGB(0, 0, 0));
	}
	void PlayerStatus::showQ()
	{
		if (_h->getCurrentAttribute() == FIRE) {
			q_pic = skill_q_fire_pic;
		}
		if (_h->getCurrentAttribute() == PLANT) {
			q_pic = skill_q_plant_pic;
		}
		if (_h->getCurrentAttribute() == ICE) {
			q_pic = skill_q_ice_pic;
		}
		int q_cd = _h->GetQCoolDown()/30;
		if (_h->GetQCoolDown() == 0) {
			q_pic.SetTopLeft(20, 0);
			q_pic.ShowBitmap();
		}
		if (_h->GetQCoolDown() != 0) {
			int first = q_cd % 10;
			q_cd /= 10;
			int second = q_cd % 10;
			Q_cooldown_first[first].SetTopLeft(50, 20);
			Q_cooldown_first[first].ShowBitmap();
			Q_cooldown_ten[second].SetTopLeft(40, 20);
			Q_cooldown_ten[second].ShowBitmap();
		}
	}
	void PlayerStatus::showE()
	{
		int e_cd = _h->GetECoolDown()/30;
		if (_h->GetECoolDown() == 0) {
			skill_e_pic.SetTopLeft(160, 0);
			skill_e_pic.ShowBitmap();
		}
		if (_h->GetECoolDown() != 0) {
			int first = e_cd % 10;
			e_cd /= 10;
			int second = e_cd % 10;
			E_cooldown_first[first].SetTopLeft(200, 20);
			E_cooldown_first[first].ShowBitmap();
			E_cooldown_ten[second].SetTopLeft(190, 20);
			E_cooldown_ten[second].ShowBitmap();
		}
	}
	void PlayerStatus::showW()
	{
		int w_cd = _h->GetWCoolDown()/30;
		if (_h->GetWCoolDown() == 0) {
			skill_w_pic.SetTopLeft(90, 0);
			skill_w_pic.ShowBitmap();
		}
		if (_h->GetWCoolDown() != 0) {
			int first = w_cd % 10;
			w_cd /= 10;
			int second = w_cd % 10;
			W_cooldown_first[first].SetTopLeft(125, 20);
			W_cooldown_first[first].ShowBitmap();
			W_cooldown_ten[second].SetTopLeft(115, 20);
			W_cooldown_ten[second].ShowBitmap();
		}
	}
	void PlayerStatus::showR()
	{
		int r_cd = _h->GetRCoolDown() / 30;
		if (_h->GetRCoolDown() == 0) {
			skill_r_pic.SetTopLeft(230, 0);
			skill_r_pic.ShowBitmap();
		}
		if (_h->GetRCoolDown() != 0) {
			int first = r_cd % 10;
			r_cd /= 10;
			int second = r_cd % 10;
			R_cooldown_first[first].SetTopLeft(275, 20);
			R_cooldown_first[first].ShowBitmap();
			R_cooldown_ten[second].SetTopLeft(265, 20);
			R_cooldown_ten[second].ShowBitmap();
		}
	}
	void PlayerStatus::showHP()
	{
		int hp = _h->getHP();
		if (hp != 0) {
			int first = hp % 10;
			hp /= 10;
			int second = hp % 10;
			hp /= 10;
			int third = hp % 10;
			hp /= 10;
			int forth = hp % 10;
			HP_first[first].SetTopLeft(500, 0);
			HP_first[first].ShowBitmap();
			HP_ten[second].SetTopLeft(490, 0);
			HP_ten[second].ShowBitmap();
			HP_hundred[third].SetTopLeft(480, 0);
			HP_hundred[third].ShowBitmap();
			HP_thousand[forth].SetTopLeft(470, 0);
			HP_thousand[forth].ShowBitmap();
		}
	}
	void PlayerStatus::showAttackFire()
	{
		int att_fire = _h->get_attack_fire();
		if (att_fire != 0) {
			int first = att_fire % 10;
			att_fire /= 10;
			int second = att_fire % 10;
			att_fire /= 10;
			int third = att_fire % 10;
			att_fire /= 10;
			int forth = att_fire % 10;
			attack_fire_first[first].SetTopLeft(500, 20);
			attack_fire_first[first].ShowBitmap();
			attack_fire_ten[second].SetTopLeft(490, 20);
			attack_fire_ten[second].ShowBitmap();
			attack_fire_hundred[third].SetTopLeft(480, 20);
			attack_fire_hundred[third].ShowBitmap();
			attack_fire_thousand[forth].SetTopLeft(470, 20);
			attack_fire_thousand[forth].ShowBitmap();
		}
	}
	void PlayerStatus::showAttackIce()
	{
		int att_ice = _h->get_attack_ice();
		if (att_ice != 0) {
			int first = att_ice % 10;
			att_ice /= 10;
			int second = att_ice % 10;
			att_ice /= 10;
			int third = att_ice % 10;
			att_ice /= 10;
			int forth = att_ice % 10;
			attack_ice_first[first].SetTopLeft(500, 40);
			attack_ice_first[first].ShowBitmap();
			attack_ice_ten[second].SetTopLeft(490, 40);
			attack_ice_ten[second].ShowBitmap();
			attack_ice_hundred[third].SetTopLeft(480, 40);
			attack_ice_hundred[third].ShowBitmap();
			attack_ice_thousand[forth].SetTopLeft(470, 40);
			attack_ice_thousand[forth].ShowBitmap();
		}
	}
	void PlayerStatus::showAttackPlant()
	{
		int att_plant = _h->get_attack_plant();
		if (att_plant != 0) {
			int first = att_plant % 10;
			att_plant /= 10;
			int second = att_plant % 10;
			att_plant /= 10;
			int third = att_plant % 10;
			att_plant /= 10;
			int forth = att_plant % 10;
			attack_plant_first[first].SetTopLeft(500, 60);
			attack_plant_first[first].ShowBitmap();
			attack_plant_ten[second].SetTopLeft(490, 60);
			attack_plant_ten[second].ShowBitmap();
			attack_plant_hundred[third].SetTopLeft(480, 60);
			attack_plant_hundred[third].ShowBitmap();
			attack_plant_thousand[forth].SetTopLeft(470, 60);
			attack_plant_thousand[forth].ShowBitmap();
		}
	}
	void PlayerStatus::showItemsOfPlayer()
	{
		for (int i = 0; i < 6; i++) {
			if (_h->getItemsOfPlayer()->at(i) != nullptr) {
				_h->getItemsOfPlayer()->at(i)->showOnStatusBar(i);
			}
		}
	}
}

PlayerStatus.h
#ifndef __PLAYERSTATUS_H
#define __PLAYERSTATUS_H
#include "Maps.h"
#include "Character.h"
#include "Hero.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class作為一個介面 : 												   //
	// 顯示冷卻，生命值以及各項數值											   //
	/////////////////////////////////////////////////////////////////////////////
	class PlayerStatus
	{
	public:
		PlayerStatus();
		void Initialize(Hero *h);
		void loadPlayerStatus();
		void showPlayerStatus();
		void setXY(int x, int y);
		void loadDigitsBitmap(CMovingBitmap a[]);		//傳入一個bitmap陣列 對陣列load 1-9的bitmap
		void showQ();									//把技能圖片show再狀態條上
		void showE();
		void showW();
		void showR();
		void showHP();
		void showAttackFire();
		void showAttackIce();
		void showAttackPlant();
		void showItemsOfPlayer();						//把道具圖片show在技能條上
	private:
		int _x, _y;
		CMovingBitmap status_bar;
		CMovingBitmap q_pic;
		CMovingBitmap skill_q_fire_pic;
		CMovingBitmap skill_q_ice_pic;
		CMovingBitmap skill_q_plant_pic;
		CMovingBitmap skill_e_pic;
		CMovingBitmap skill_w_pic;
		CMovingBitmap skill_r_pic;
		CMovingBitmap HP_first[10];						//hp個十百千
		CMovingBitmap HP_ten[10];
		CMovingBitmap HP_hundred[10];
		CMovingBitmap HP_thousand[10];
		CMovingBitmap Q_cooldown_first[10];				//技能冷卻時間的十位個位數
		CMovingBitmap Q_cooldown_ten[10];
		CMovingBitmap W_cooldown_first[10];
		CMovingBitmap W_cooldown_ten[10];
		CMovingBitmap E_cooldown_first[10];
		CMovingBitmap E_cooldown_ten[10];
		CMovingBitmap R_cooldown_first[10];
		CMovingBitmap R_cooldown_ten[10];
		CMovingBitmap attack_fire_first[10];
		CMovingBitmap attack_fire_ten[10];
		CMovingBitmap attack_fire_hundred[10];
		CMovingBitmap attack_fire_thousand[10];
		CMovingBitmap attack_ice_first[10];
		CMovingBitmap attack_ice_ten[10];
		CMovingBitmap attack_ice_hundred[10];
		CMovingBitmap attack_ice_thousand[10];
		CMovingBitmap attack_plant_first[10];
		CMovingBitmap attack_plant_ten[10];
		CMovingBitmap attack_plant_hundred[10];
		CMovingBitmap attack_plant_thousand[10];
		Hero *_h;
	};
}
#endif 
Potion.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "Potion.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//Potion: Item class
	/////////////////////////////////////////////////////////////////////////////
	Potion::Potion()
	{
	}
	void Potion::load()
	{
		potion_pic.LoadBitmap(IDB_ITEMPOTION);
		item_on_status_bar.LoadBitmapA(IDB_ITEMPOTION);
	}
	void Potion::OnMove(Maps *m, Hero *h)
	{
		_x = getX();
		_y = getY();
		if (isExist() && intercect(h) && getNumOfBox() % 100 > 50 &&  getNumOfBox() % 100 <= 75)  //如果num_ofBox%100 = 50-75 箱子會掉這個道具
		{
			Potion * p = new Potion();
			p->load();
			h->addItem(p);					//push給英雄道具欄的vector
			setExist(false);
		}
	}
	void Potion::OnShow(Maps *m)
	{
		if (isExist() && getNumOfBox() % 100 > 50 && getNumOfBox() % 100 <= 75)
		{
			potion_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
			potion_pic.ShowBitmap();
		}
	}
	void Potion::effect(Hero *h)
	{
		for (int i = 0; i < 100; i++)				//使用藥水後會增加100hp，但不會加超過最大生命
		{
			if (h->getHP() < h->getFullHP()) 
			{
				h->addHp(1);
			}
		}
		setIsUsed(false);
	}
	bool Potion::intercect(Hero * h)
	{
		if (isExist()) 
		{
			if (h->GetX2() >= _x + 10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
}

Potion.h
#ifndef __POTION_H
#define __POTION_H
#include "Maps.h"
#include "Character.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具 : 藥水												   //
	// 道具可由箱子或擊殺怪物獲得											   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class Potion: public Item
	{
	public:
		Potion();
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		void effect(Hero *h);			//使用道具的效果
		bool intercect(Hero *h) ;
	private:
		int _x, _y;
		CMovingBitmap potion_pic;
	};
}
#endif
ProtectiveCover.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "ProtectiveCover.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//ProtectiveCover: Item class
	/////////////////////////////////////////////////////////////////////////////
	ProtectiveCover::ProtectiveCover()
	{
	}
	void ProtectiveCover::load()
	{
		clock_pic.LoadBitmap(".\\bitmaps\\protected_cover.bmp", RGB(195, 195, 195));
		item_on_status_bar.LoadBitmapA(".\\bitmaps\\protected_cover.bmp");
	}
	void ProtectiveCover::OnMove(Maps *m, Hero *h)
	{
		_x = getX();
		_y = getY();
		if (isExist() && intercect(h) && getNumOfBox() % 100 > 0 && getNumOfBox() % 100 <= 20)  //如果num_ofBox%100 = 0-20 箱子會掉這個道具
		{	
			//用num_of_box決定這個道具會不會掉落
			ProtectiveCover * p = new ProtectiveCover();
			p->load();
			h->addItem(p);
			setExist(false);
		}
	}
	void ProtectiveCover::OnShow(Maps *m)
	{
		if (isExist() && getNumOfBox() % 100 > 0 && getNumOfBox() % 100 <= 20)
		{
			clock_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
			clock_pic.ShowBitmap();
		}
	}
	void ProtectiveCover::effect(Hero *h)						
	{
		//使用道具的話 英雄就會進入不會被攻擊到的模式
		h->setCantBeDamaged(true);
		setIsUsed(false);
	}
	bool ProtectiveCover::intercect(Hero * h)
	{
		if (isExist()) {
			if (h->GetX2() >= _x + 10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
}

ProtectiveCover.h
#ifndef __PRETECTEDCOVER_H
#define __PROTECTEDCOVER_H
#include "Maps.h"
#include "Character.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具 : 防護罩											   //
	// 道具可由箱子或擊殺怪物獲得											   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class ProtectiveCover: public Item
	{
	public:
		ProtectiveCover();
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		void effect(Hero *h);				//道具的效果
		bool intercect(Hero *h) ;
	private:
		int _x, _y;
		CMovingBitmap clock_pic;
	};
}
#endif
RandomAttribute.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "Clock.h"
#include "RandomAttribute.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//RandomAttribute: Item class
	/////////////////////////////////////////////////////////////////////////////
	RandomAttribute::RandomAttribute()
	{
	}
	void RandomAttribute::load()
	{
		random_attribute_pic.LoadBitmap(IDB_ITEMRANDOMATTRIBUTE);
		item_on_status_bar.LoadBitmapA(IDB_ITEMRANDOMATTRIBUTE);
	}
	void RandomAttribute::OnMove(Maps *m, Hero *h)
	{
		_x = getX();
		_y = getY();
		if (isExist() && intercect(h) && getNumOfBox() % 100 > 75)		//如果num_ofBox%100 = 75-100 箱子會掉這個道具
		{
			RandomAttribute * p = new RandomAttribute();
			p->load();
			h->addItem(p);
			setExist(false);
		}
	}
	void RandomAttribute::OnShow(Maps *m)
	{
		if (isExist() && getNumOfBox() % 100 > 75) 
		{
			random_attribute_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
			random_attribute_pic.ShowBitmap();
		}
	}
	void RandomAttribute::effect(Hero *h)
	{
		//隨機一種屬性
		int n = rand() % 2;
		if (h->getCurrentAttribute() == FIRE) 
		{
			if (n == 0)
			{
				//切換屬性
				h->SetElementAttribute(ICE);
			}
			else if (n == 1) 
			{
				h->SetElementAttribute(PLANT);
			}
		}
		else if (h->getCurrentAttribute() == ICE) 
		{
			if (n == 0) 
			{
				h->SetElementAttribute(FIRE);
			}
			else if (n == 1) 
			{
				h->SetElementAttribute(PLANT);
			}
		}
		else if (h->getCurrentAttribute() == PLANT)
		{
			if (n == 0) 
			{
				h->SetElementAttribute(FIRE);
			}
			else if (n == 1) 
			{
				h->SetElementAttribute(ICE);
			}
		}
		setIsUsed(false);
	}
	bool RandomAttribute::intercect(Hero * h)
	{
		if (isExist()) 
		{
			if (h->GetX2() >= _x + 10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
}

RandomAttribute.h
#ifndef __RANDOMATTRIBUTE_H
#define __RANDOMATTRIBUTE_H
#include "Maps.h"
#include "Character.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具 : 隨機變換屬性										   //
	// 道具可由箱子或擊殺怪物獲得											   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class RandomAttribute: public Item
	{
	public:
		RandomAttribute();
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		void effect(Hero *h);				//使用道具後的效果
		bool intercect(Hero *h) ;
	private:
		int _x, _y;
		int rand_num;
		CMovingBitmap random_attribute_pic;
	};
}
#endif
RedGoblin.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Arrow.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "RedGoblin.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueGoblin.cpp 												   //
	/////////////////////////////////////////////////////////////////////////////
	RedGoblin::RedGoblin()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	RedGoblin::RedGoblin(int x, int y, Hero *h) : Enemy(x, y, 1200, "RedGoblin", h, FIRE)
	{
		attack_damage = 20;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));
	}
	RedGoblin::~RedGoblin()
	{
	}
	void RedGoblin::LoadBitmap()
	{
		blood_bar.loadBloodBar();
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->load();
		}
		char *filename1_1[4] = { ".\\bitmaps\\redgoblinL1.bmp",".\\bitmaps\\redgoblinL2.bmp",".\\bitmaps\\redgoblinL3.bmp", ".\\bitmaps\\redgoblinL4.bmp" };
		for (int i = 0; i < 4; i++)	
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[4] = { ".\\bitmaps\\redgoblinR1.bmp",".\\bitmaps\\redgoblinR2.bmp",".\\bitmaps\\redgoblinR3.bmp", ".\\bitmaps\\redgoblinR4.bmp" };
		for (int i = 0; i < 4; i++)
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		arrowAttackL.LoadBitmap(".\\bitmaps\\red_arrow_attackL.bmp", RGB(0, 0, 0));
		arrowAttackR.LoadBitmap(".\\bitmaps\\red_arrow_attackR.bmp", RGB(0, 0, 0));
		arr.loadBitmap();
	}
	void RedGoblin::OnMove(Maps * m) 
	{
		const int STEP_SIZE = 4;
		if (isAlive()) 
		{
			attack_cool_down -= 1;
			walkingLeft.OnMove();
			walkingRight.OnMove();
			movement(m);
			arrowAttack();
			arr.OnMove(m);
			arrowAttackMove(m);
			if (arrowAttackCD != 0) 
			{
				arrowAttackCD--;
			}
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);
		}
	}
	void RedGoblin::OnShow(Maps *m)
	{
		if (isAlive()) 
		{
			if (_direction == 0)
			{
				if (isAttacking)
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp - 16);
					arrowAttackShow(m);
				}
				else 
				{
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
				}
			}
			else
			{
				if (isAttacking) 
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
					arrowAttackShow(m);
				}
				else 
				{
					blood_bar.setXY(GetX1(), GetY1()-16);
					blood_bar.showBloodBar(m, hp);
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
				}
			}
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int RedGoblin::GetX1()
	{
		return _x;
	}
	int RedGoblin::GetY1()
	{
		return _y;
	}
	int RedGoblin::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int RedGoblin::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void RedGoblin::Initialize() 
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking = attackIsFlying = false;
		hp = 1200;
		arrorClock = 0;
		arrowAttackCD = 0;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->Initialize();
		}
	}
	bool RedGoblin::intersect(int x1, int x2, int y1, int y2)
	{
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + walkingRight.Width() - 20 && y2 >= _y + 30 && y1 <= _y + walkingRight.Height() - 15)
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	void RedGoblin::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void RedGoblin::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void RedGoblin::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void RedGoblin::SetMovingRight(bool b) 
	{
		isMovingRight = b;
	}
	void RedGoblin::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void RedGoblin::movement(Maps *m)
	{
		int x = GetX1();
		int y1 = GetY1() ;
		if (_x > hero_on_map->GetX1()) 
		{
			_direction = 0;
		}
		else 
		{
			_direction = 1;
		}
		int step_size = rand() % 3;
		if (_x != hero_on_map->GetX1() && _y != hero_on_map->GetY1()) 
		{
			if (abs(_x - hero_on_map->GetX1()) > abs(_y - hero_on_map->GetY1()))
			{
				if (_y > hero_on_map->GetY1())
					_y -= step_size;
				else
					_y += step_size;
			}
			else
			{
				if (_x > hero_on_map->GetX1())
					_x -= step_size;
				else
					_x += step_size;
			}
		}
	}
	void RedGoblin::arrowAttack()
	{
		if (!isAttacking && arrowAttackCD == 0)
		{
			if (_y == hero_on_map->GetY1() && hero_on_map->GetX1() <= _x)
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(0);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_y == hero_on_map->GetY1() && hero_on_map->GetX1() > _x)
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(1);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_x == hero_on_map->GetX1() && hero_on_map->GetY1() <= _y )
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(2);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
			if (_x == hero_on_map->GetX1() && hero_on_map->GetY1() > _y )
			{
				arrorClock = 60;
				arr.setAttackIsFlying(true);
				arr.setDirection(3);
				arr.setArrowXY(_x+32, _y+25);
				isAttacking = true;
				arrowAttackCD = 180;
			}
		}
	}
	void RedGoblin::arrowAttackMove(Maps * m)
	{
		if (isAttacking) 
		{
			if (hero_on_map->intercect(arr.getX1(), arr.getX2(), arr.getY1(), arr.getY2())) 
			{
				hero_on_map->offsetHp(attack_damage);
			}
		}
		if (isAttacking && arrorClock != 0) 
		{
			arrorClock--;
			if (arrorClock == 0) 
			{
				isAttacking = false;
			}
		}
	}
	void RedGoblin::arrowAttackShow(Maps * m)
	{
		if (isAttacking) 
		{
			if (_direction == 0)
			{
				arrowAttackL.SetTopLeft(m->screenX(_x), m->screenY(_y));
				arrowAttackL.ShowBitmap();
				arr.OnShow(m);
			}
			if (_direction == 1)
			{
				arrowAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
				arrowAttackR.ShowBitmap();
				arr.OnShow(m);
			}
		}
	}
}

RedGoblin.h
#ifndef REDGOBLIN_H
#define REDGOBLIN_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
#include "Arrow.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueGoblin.h 												   //
	/////////////////////////////////////////////////////////////////////////////
	class Arrow;
	class RedGoblin :public Enemy
	{
	public:
		RedGoblin();
		RedGoblin(int x, int y, Hero *h);
		~RedGoblin();
		void LoadBitmap();
		void OnShow(Maps *m) override;
		void OnMove(Maps *m);
		int GetX1();
		int GetY1();
		int GetX2();
		int GetY2();
		void Initialize()override;
		bool intersect(int x1, int x2, int y1, int y2) override;
		void SetMovingDown(bool b);
		void SetMovingUp(bool b);
		void SetMovingLeft(bool b);
		void SetMovingRight(bool b);
		void SetXY(int x, int y);
		void movement(Maps *m);
		void arrowAttack();
		void arrowAttackMove(Maps *m);
		void arrowAttackShow(Maps *m);
	private:
		CMovingBitmap arrowAttackL;
		CMovingBitmap arrowAttackR;
		CAnimation walkingLeft;
		CAnimation walkingRight;
		Arrow arr;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		bool attackIsFlying;
		int attack_cool_down;
		int move_or_not;
		int time_bump_into_sth;
		int arrowAttackCD;
		int arrorClock;
	};
}
#endif 
RedSlime.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <cmath>
#include <ctgmath>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "RedSlime.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueSlime.cpp												   //
	/////////////////////////////////////////////////////////////////////////////
	RedSlime::RedSlime()
	{
		_x = 384;
		_y = 384;
		attack_damage = 0;
	}
	RedSlime::RedSlime(int x, int y, Hero *h) : Enemy(x, y, 1200, "RedSlime", h, FIRE)
	{
		attack_damage = 70;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(_attribute));
	}
	RedSlime::~RedSlime()
	{
	}
	void RedSlime::LoadBitmap()
	{
		blood_bar.loadBloodBar();
		for (unsigned i = 0; i < items.size(); i++)
		{
			items.at(i)->load();
		}
		char *filename1_1[3] = { ".\\bitmaps\\redslimeL1.bmp",".\\bitmaps\\redslimeL2.bmp",".\\bitmaps\\redslimeL3.bmp" };
		for (int i = 0; i < 3; i++)
			walkingLeft.AddBitmap(filename1_1[i], RGB(0, 0, 0));
		char *filename1_2[3] = { ".\\bitmaps\\redslimeR1.bmp",".\\bitmaps\\redslimeR2.bmp",".\\bitmaps\\redslimeR3.bmp"};
		for (int i = 0; i < 3; i++)	
			walkingRight.AddBitmap(filename1_2[i], RGB(0, 0, 0));
		char *filename2_1[5] = { ".\\bitmaps\\redslime_attackL1.bmp",".\\bitmaps\\redslime_attackL2.bmp",".\\bitmaps\\redslime_attackL3.bmp", ".\\bitmaps\\redslime_attackL4.bmp", ".\\bitmaps\\redslime_attackL5.bmp" };
		for (int i = 0; i < 5; i++)	
			normalAttackL.AddBitmap(filename2_1[i], RGB(0, 0, 0));
		normalAttackL.SetDelayCount(3);
		char *filename2_2[5] = { ".\\bitmaps\\redslime_attackR1.bmp",".\\bitmaps\\redslime_attackR2.bmp",".\\bitmaps\\redslime_attackR3.bmp", ".\\bitmaps\\redslime_attackR4.bmp", ".\\bitmaps\\redslime_attackR5.bmp" };
		for (int i = 0; i < 5; i++)	
			normalAttackR.AddBitmap(filename2_2[i], RGB(0, 0, 0));
		normalAttackR.SetDelayCount(3);
	}
	void RedSlime::OnMove(Maps * m) 
	{
		const int STEP_SIZE = 4;
		if (isAlive()) 
		{
			attack();
			attack_cool_down -= 1;
			walkingLeft.OnMove();
			walkingRight.OnMove();
			movement(m);
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);
		}
	}
	void RedSlime::OnShow(Maps *m)
	{
		if (isAlive()) 
		{
			if (_direction == 0)
			{
				if (isAttacking)
				{
					attackShow(m);
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
				else 
				{
					walkingLeft.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingLeft.OnShow();
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
			}
			else
			{
				if (isAttacking)
				{
					attackShow(m);
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
				else 
				{
					walkingRight.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
					walkingRight.OnShow();
					blood_bar.setXY(GetX1(), GetY1());
					blood_bar.showBloodBar(m, hp);
				}
			}
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int RedSlime::GetX1()
	{
		return _x;
	}
	int RedSlime::GetY1()
	{
		return _y;
	}
	int RedSlime::GetX2()
	{
		return _x + walkingRight.Width();
	}
	int RedSlime::GetY2()
	{
		return _y + walkingRight.Height();
	}
	void RedSlime::Initialize() 
	{
		_x = ini_x;
		_y = ini_y;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = isAttacking =  false;
		hp = 1200;
		blood_bar.setFullHP(hp);
		walkingLeft.SetDelayCount(5);
		walkingRight.SetDelayCount(5);
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->Initialize();
		}
	}
	bool RedSlime::intersect(int x1, int x2, int y1, int y2)
	{
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + walkingRight.Width() - 20 && y2 >= _y + 30 && y1 <= _y + walkingRight.Height() - 15)
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
	void RedSlime::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void RedSlime::SetMovingUp(bool b)
	{
		isMovingUp = b;
	}
	void RedSlime::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void RedSlime::SetMovingRight(bool b) 
	{
		isMovingRight = b;
	}
	void RedSlime::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void RedSlime::movement(Maps *m)
	{
		int x = GetX1();
		int y1 = GetY1() ;
		int step_size = rand() % 3;
		if (distanceToHero() < 500) 
		{
			if (hero_on_map->GetX1() > x && m->isEmpty(GetX2() + step_size, y1) && m->isEmpty(GetX2() + step_size, GetY2())) 
			{
				_direction = 1;
				_x += step_size;
			}
			if (hero_on_map->GetX1() < x && m->isEmpty(x - step_size, y1) && m->isEmpty(x - step_size, GetY2())) 
			{
				_direction = 0;
				_x -= step_size;
			}
			if (hero_on_map->GetY1() > y1 && m->isEmpty(x, GetY2() + step_size) && m->isEmpty(GetX2(), GetY2() + step_size))
			{
				_y += step_size;
			}
			if (hero_on_map->GetY1() < y1 && m->isEmpty(x, y1 - step_size) && m->isEmpty(GetX2(), y1 - step_size))
			{
				_y -= step_size;
			}
		}
	}
	void RedSlime::attack()
	{
		if (intersect(hero_on_map->GetX1(), hero_on_map->GetX2(), hero_on_map->GetY1(), hero_on_map->GetY2()) && attack_cool_down <= 0 && !isAttacking) 
		{
			CAudio::Instance()->Play(AUDIO_HITTING);
			isAttacking = true;
			hero_on_map->offsetHp(attack_damage);
		}
		normalAttackR.OnMove();
		if (!isAttacking) 
		{
			normalAttackR.Reset();
		}
	}
	void RedSlime::attackShow(Maps * m)
	{
		if (isAttacking) 
		{
			normalAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
			normalAttackR.OnShow();
			if (normalAttackR.IsFinalBitmap()) 
			{
				isAttacking = false;
				attack_cool_down = 90; 
			}
		}
	}
}

RedSlime.h
#ifndef REDSLIME_H
#define REDSLIME_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	//註解請參照BlueSlime.h 													   //
	/////////////////////////////////////////////////////////////////////////////
	class RedSlime :public Enemy
	{
	public:
		RedSlime();									
		RedSlime(int x, int y, Hero *h);			
		~RedSlime();
		void LoadBitmap();							
		void OnShow(Maps *m) override;				
		void OnMove(Maps *m);			
		int GetX1();								
		int GetY1();								
		int GetX2();								
		int GetY2();					
		void Initialize()override;
		bool intersect(int x1, int x2, int y1, int y2) override;
		void SetMovingDown(bool b);		
		void SetMovingUp(bool b);		
		void SetMovingLeft(bool b);		
		void SetMovingRight(bool b);	
		void SetXY(int x, int y);		
		void movement(Maps *m);
		void attack();
		void attackShow(Maps *m);
	private:
		CAnimation walkingLeft;
		CAnimation walkingRight;
		CAnimation normalAttackL;
		CAnimation normalAttackR;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		bool isAttacking;
		int attack_cool_down;
		int move_or_not;
		int time_bump_into_sth;
	};
}
#endif 
Scarecrow.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Enemy.h"
#include "Enemy.h"
#include "Hero.h"
#include "Maps.h"
#include "Enemy.h"
#include "Scarecrow.h"
#include "Util.h"
#include "Item.h"
#include "ItemAttribute.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// Scarecrow: Enemy class												   //
	/////////////////////////////////////////////////////////////////////////////
	Scarecrow::Scarecrow()
	{
		_x = 384;
		_y = 384;
		hp = 1200;
		attack_damage = 0;
	}
	Scarecrow::Scarecrow(int x, int y, Hero *h) : Enemy(x, y, 1200, "scarecrow", h, PLANT)
	{
		attack_damage = 50;
		attack_cool_down = 0;
		items.push_back(new ItemAttribute(PLANT));
	}
	Scarecrow::~Scarecrow()
	{
	}
	void Scarecrow::LoadBitmap()
	{
		enemy.LoadBitmap(IDB_SCARECROW, RGB(0, 0, 0));
		////道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->load();
		}
		blood_bar.loadBloodBar();
		EnemyRect = enemy.ReturnCRect();
		/////攻擊的動畫
		char *filename[12] = { ".\\bitmaps\\Scarecrow_attack1.bmp",".\\bitmaps\\Scarecrow_attack2.bmp",".\\bitmaps\\Scarecrow_attack3.bmp",".\\bitmaps\\Scarecrow_attack4.bmp", ".\\bitmaps\\Scarecrow_attack5.bmp", ".\\bitmaps\\Scarecrow_attack6.bmp", ".\\bitmaps\\Scarecrow_attack7.bmp", ".\\bitmaps\\Scarecrow_attack8.bmp", ".\\bitmaps\\Scarecrow_attack9.bmp", ".\\bitmaps\\Scarecrow_attack10.bmp", ".\\bitmaps\\Scarecrow_attack11.bmp", ".\\bitmaps\\Scarecrow_attack12.bmp" };
		for (int i = 0; i < 6; i++)	// 載入動畫(由6張圖形構成)
			normalAttackR.AddBitmap(filename[i], RGB(0, 0, 0));
		normalAttackR.SetDelayCount(1);
	}
	void Scarecrow::OnMove(Maps * m) 
	{
		if (isAlive()) 
		{
			const int STEP_SIZE = 4;
			attack();
			attack_cool_down -= 1;
		}
		if (!isAlive()) 
		{
			itemsOnMove(m);
		}
	}
	void Scarecrow::OnShow(Maps *m)
	{
		if (isAlive()) 
		{
			if (isAttacking) 
			{
				attackShow(m);
			}
			else 
			{
				enemy.SetTopLeft(m->screenX(GetX1()), m->screenY(GetY1()));
				enemy.ShowBitmap();
				blood_bar.setXY(GetX1(), GetY1() + 50);
				blood_bar.showBloodBar(m, hp);
			}
		}
		if (!isAlive()) 
		{
			itemsOnShow(m);
		}
	}
	int Scarecrow::GetX1()
	{
		return _x;
	}
	int Scarecrow::GetY1()
	{
		return _y;
	}
	int Scarecrow::GetX2()
	{
		return _x + enemy.Width();
	}
	int Scarecrow::GetY2()
	{
		return _y + enemy.Height();
	}
	void Scarecrow::Initialize() {
		hp = 1200;
		isMovingDown = isMovingUp = isMovingLeft = isMovingRight = false;
		blood_bar.setFullHP(hp);
		////道具
		for (unsigned i = 0; i < items.size(); i++) 
		{
			items.at(i)->Initialize();
		}
	}
	bool Scarecrow::intersect(int x1, int x2, int y1, int y2)
	{
		//下面有一些加減運算是因為，稻草人的Bitmap本身比稻草人的身體大太多。
		if (isAlive()) 
		{
			if (x2 >= _x + 20 && x1 <= _x + enemy.Width() - 20 && y2 >= _y + 60 && y1 <= _y + enemy.Height() - 15) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}void Scarecrow::SetMovingDown(bool b) 
	{
		isMovingDown = b;
	}
	void Scarecrow::SetMovingUp(bool b) 
	{
		isMovingUp = b;
	}
	void Scarecrow::SetMovingLeft(bool b) 
	{
		isMovingLeft = b;
	}
	void Scarecrow::SetMovingRight(bool b) 
	{
		isMovingRight = b;
	}
	void Scarecrow::SetXY(int x, int y)
	{
		_x = x;
		_y = y;
	}
	void Scarecrow::attack()
	{
		if (intersect(hero_on_map->GetX1(), hero_on_map->GetX2(), hero_on_map->GetY1(), hero_on_map->GetY2()) && attack_cool_down <= 0 && !isAttacking) 
		{
			isAttacking = true;
			CAudio::Instance()->Play(Audio_KNIFE);
			//Hero損血
			hero_on_map->offsetHp(attack_damage);
		}
		normalAttackR.OnMove();
		if (!isAttacking) 
		{
			normalAttackR.Reset();
		}
	}
	void Scarecrow::attackShow(Maps * m)
	{
		if (isAttacking) 
		{
			normalAttackR.SetTopLeft(m->screenX(_x), m->screenY(_y));
			normalAttackR.OnShow();
			if (normalAttackR.IsFinalBitmap()) 
			{
				isAttacking = false;
				attack_cool_down = 90; //每次攻擊間隔3秒
			}
		}
	}
}

Scarecrow.h
#ifndef SCARECROW_H
#define SCARECROW_H
#include "Maps.h"
#include "Character.h"
#include "BloodBar.h"
#include "Enemy.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供一個敵人												   //
	// 一個稻草人 															   //
	/////////////////////////////////////////////////////////////////////////////
	class Scarecrow :public Enemy
	{
	public:
		Scarecrow();								//建構子，傳給Character角色名稱
		Scarecrow(int x, int y, Hero *h);			//建構子，設定角色初始位置給Character()，方便vector一次建立
		~Scarecrow();
		void LoadBitmap();							//加載敵人Bitmap
		void OnShow(Maps *m) override;				//顯示敵人於畫面上
		void OnMove(Maps *m);						//敵人移動
		///以下函式回傳座標
		int GetX1();								//回傳最左側X值
		int GetY1();								//回傳最上側Y值
		int GetX2();								//回傳最右側X值
		int GetY2();								//回傳最下側Y值
		///以下函式初始化
		void Initialize()override;				
		///英雄是否和此敵人所在同一位置
		bool intersect(int x1, int x2, int y1, int y2) override;
		/////////////////////////////////////////////////////////////////////////////
		// 設定Enemy的座標的函式們												   //
		/////////////////////////////////////////////////////////////////////////////
		void SetMovingDown(bool b);					//下
		void SetMovingUp(bool b);					//上
		void SetMovingLeft(bool b);					//左
		void SetMovingRight(bool b);				//右
		void SetXY(int x, int y);					//x, y座標
		//用來攻擊的
		void attack();
		void attackShow(Maps *m);
	private:
		CMovingBitmap enemy;
		CAnimation normalAttackR;
		int attack_damage;
		bool isMovingRight;
		bool isMovingLeft;
		bool isMovingUp;
		bool isMovingDown;
		int attack_cool_down;						//攻擊的冷卻時間
	};
}
#endif 
Shoe.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "Hero.h"
#include "Maps.h"
#include "Item.h"
#include "Shoe.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// Shoe: Item class														   //
	/////////////////////////////////////////////////////////////////////////////
	Shoe::Shoe()
	{
	}
	void Shoe::load()
	{
		clock_pic.LoadBitmap(".\\bitmaps\\shoes.bmp", RGB(246, 246, 246));
		item_on_status_bar.LoadBitmapA(".\\bitmaps\\shoes.bmp", RGB(246, 246, 246));
	}
	void Shoe::OnMove(Maps *m, Hero *h)
	{
		_x = getX();
		_y = getY();
		if (isExist() && intercect(h) && getNumOfBox() % 100 > 20 && getNumOfBox() % 100 <= 40)  //如果num_ofBox%100 = 20-40 箱子會掉這個道具
		{
			Shoe * p = new Shoe();
			p->load();
			h->addItem(p);
			setExist(false);
		}
	}
	void Shoe::OnShow(Maps *m)
	{
		if (isExist() && getNumOfBox() % 100 > 20 && getNumOfBox() % 100 <= 40) 
		{
			clock_pic.SetTopLeft(m->screenX(_x), m->screenY(_y));
			clock_pic.ShowBitmap();
		}
		
	}
	void Shoe::effect(Hero *h)
	{
		//改變Hero的速度(瞬間加速)
		h->setSpeedUp(true);
		setIsUsed(false);
	}
	bool Shoe::intercect(Hero * h)
	{
		if (isExist()) 
		{
			if (h->GetX2() >= _x + 10 && h->GetX1() <= _x + 20 && h->GetY2() >= _y + 10 && h->GetY1() <= _y + 20) 
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
		return false;
	}
}

Shoe.h
#ifndef __SHOE_H
#define __SHOE_H
#include "Maps.h"
#include "Character.h"
namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// 這個class提供道具 : 加跑速的鞋子										   //
	// 道具可由箱子或擊殺怪物獲得												   //
	/////////////////////////////////////////////////////////////////////////////
	class Hero;
	class Shoe: public Item
	{
	public:
		Shoe();
		void load();
		void OnMove(Maps *m, Hero *h);
		void OnShow(Maps *m);
		void effect(Hero *h);			//道具的效果
		bool intercect(Hero *h) ;
	private:
		int _x, _y;
		CMovingBitmap clock_pic;
	};
}

#endif
Util.h
#ifndef UTIL_H
#define UTIL_H

	/////////////////////////////////////////////////////////////////////////////
	// 這個.h file 定義了參數的值，可以直接從這裡取用						   //
	/////////////////////////////////////////////////////////////////////////////
	constexpr int OBJS_DEFAULT_SPEED = 4; //物件固定移動速度;
	constexpr int SMOOTH_MOVE_TRESHOLD = OBJS_DEFAULT_SPEED * 3 - 1; //平滑移動門檻值
	constexpr int HERO_MOVE_SPEED = 5;		//英雄移動速度
	constexpr int SKILL_EVO_TVALUE = 22;	//技能進化的Treshold Value
	constexpr int MAX_ENEMY_PER_MAP = 10;//最大的敵人存量
	const double PROB_ENEMY_TURN = 0.02;//敵人自動轉向機率
	const double PROB_ITEM_GEN = 0.005;//打死敵人生寶物的機率
	///以下為各鍵值
	const char KEY_LEFT = 0x25; // keyboard左箭頭
	const char KEY_UP = 0x26; // keyboard上箭頭
	const char KEY_RIGHT = 0x27; // keyboard右箭頭
	const char KEY_DOWN = 0x28; // keyboard下箭頭
	const char KEY_A = 0x41;
	const char KEY_Q = 0x51;
	const char KEY_W = 0x57;
	const char KEY_E = 0x45;
	const char KEY_R = 0x52;
	const char CTRL = 17;
	const char NUM_0 = 0x30;	
	const char NUM_1 = 0x31;
	const char NUM_2 = 0x32;
	const char NUM_3 = 0x33;
	const char NUM_4 = 0x34;
	const char NUM_5 = 0x35;
	const char NUM_6 = 0x36;
	const char NUM_7 = 0x37;
	const char NUM_8 = 0x38;
	const char NUM_9 = 0x39	;
	//以下是一些留給跳躍關卡快捷鍵
	const char J_STG1_1 = 0x5A; //Z
	const char J_STG1_2 = 0x58 ; //X
	const char J_STG1_4 = 0x43; //C
	const char J_STG1_6 = 0x56; //V
	const char J_STG2_1 = 0x42; //B
	const char J_STG2_2 = 0x4E; //N
	const char J_STG2_3 = 0x4D; //M
	const char J_STG2_4 = 0x4A; //J
	///音效
	enum AUDIO_ID {				// 定義各種音效的編號
		AUDIO_DING,				// 0
		AUDIO_LAKE,				// 1
		AUDIO_NTUT,				// 2
		AUDIO_GOLDENWIND,		// 3
		AUDIO_SWORD,			// 4
		AUDIO_FIRE,				//......以此類推
		AUDIO_SKILLE,			
		AUDIO_SKILLR_1,			
		AUDIO_SKILLR_2,			
		Audio_KNIFE,			
		AUDIO_ICE,
		AUDIO_HITTING,
		AUDIO_GRASSBALL,
		AUDIO_BEGGER,
		AUDIO_AWAKEN,
		AUDIO_DAMAGE1,
		AUDIO_ABOSS_WALK,
		AUDIO_ABOSS_PREPARE,
		AUDIO_GOODFLASH,
		AUDIO_BADFLASH,
		AUDIO_GAMEOVER,
		AUDIO_ICEBIRD_DIE,
		AUDIO_CHOOSE,
		AUDIO_BEING_ATTACKED,
		AUDIO_SCOLD,
		AUDIO_SHOE,
		AUDIO_SING
	};
	// 定義各關卡的編號
	enum STAGE {				
		STAGE_1_1,				
		STAGE_1_2,
		STAGE_1_3,
		STAGE_1_4,
		STAGE_2_1,
		STAGE_2_2,
		STAGE_2_3,
		STAGE_2_4,
		CONGRATULATION
	};
	// 定義各種屬性的編號
	enum ELEMENT_ATTRIBUTE {
		FIRE,					//火屬性
		ICE,					//冰屬性
		PLANT,					//植物屬性
		NO,

	};
	// 定義各種攻擊的編號
	enum ATTACK_NAME {
		FIRE_BALL,				//火球
		ICE_BALL,				//Q技能的冰
		GRASS_BALL,				//Q技能的草
		FIRE_FLAME,
		GRASS_TORNADO,
	};
#endif
mygame.cpp
#include "stdafx.h"
#include "Resource.h"
#include <mmsystem.h>
#include <algorithm>
#include <ddraw.h>
#include "audio.h"
#include "gamelib.h"
#include "mygame.h"
#include "Character.h"
#include "BlueSlime.h"
#include "GreenSlime.h"
#include "RedSlime.h"
#include "RedGoblin.h"
#include "IceBird.h"
#include "Util.h"
namespace game_framework {
	/////////////////////////////////////////////////////////////////////////////
	// mygame.cpp: 本檔案儲遊戲本身的class的implementation					   //
	// 這個class為遊戲的遊戲開頭畫面物件										   //
	/////////////////////////////////////////////////////////////////////////////
	CGameStateInit::CGameStateInit(CGame *g)
		: CGameState(g)
	{
	}
	void CGameStateInit::OnInit()
	{
		// 當圖很多時，OnInit載入所有的圖要花很多時間。為避免玩遊戲的人
		// 等的不耐煩，遊戲會出現「Loading ...」，顯示Loading的進度。
		ShowInitProgress(0);	// 一開始的loading進度為0%
		// 開始載入資料
		CAudio::Instance()->Load(AUDIO_CHOOSE, "sounds\\choose.mp3");	
		goto_status = isHelp = isAbout = 0;
		logo.LoadBitmap(IDB_STARTBACKGROUND);
		selection.LoadBitmap(".\\bitmaps\\choose.bmp");
		help.LoadBitmap(".\\RES\\help.bmp");
		about.LoadBitmap(".\\RES\\credits.bmp");
		choose.LoadBitmap(".\\Bitmaps\\choose.bmp", RGB(0, 0, 0));
		// 此OnInit動作會接到CGameStaterRun::OnInit()，所以進度還沒到100%
	}
	void CGameStateInit::OnBeginState()
	{
	}
	void CGameStateInit::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
	{
		const char KEY_ESC = 27;
		const char KEY_SPACE = ' ';
		if (nChar == KEY_UP && goto_status > 0)
		{
			CAudio::Instance()->Play(AUDIO_CHOOSE, false);
			goto_status -= 1;
		}
		if (nChar == KEY_DOWN && goto_status < 2)
		{
			CAudio::Instance()->Play(AUDIO_CHOOSE, false);
			goto_status += 1;
		}
		if (nChar == KEY_SPACE)
		{
			if (goto_status == 0)
				GotoGameState(GAME_STATE_RUN);						// 切換至GAME_STATE_RUN
			else if (goto_status == 1)
			{
				if (isHelp == 0)
				{
					isHelp = 1;
				}
				else
					isHelp = 0;
			}
			else if (goto_status == 2)
			{
				if (isAbout == 0)
				{
					isAbout = 1;
				}
				else
					isAbout = 0;
			}	
		}
		else if (nChar == KEY_ESC)								// Demo 關閉遊戲的方法
			PostMessage(AfxGetMainWnd()->m_hWnd, WM_CLOSE, 0, 0);	// 關閉遊戲
	}
	void CGameStateInit::OnLButtonDown(UINT nFlags, CPoint point)
	{
	}
	void CGameStateInit::OnShow()
	{
		//
		// 貼上logo
		//
		logo.SetTopLeft(0, 0);
		logo.ShowBitmap();
		if (isHelp)
		{
			help.SetTopLeft(0, 0);
			help.ShowBitmap();
		}
		if (isAbout)
		{
			about.SetTopLeft(0, 0);
			about.ShowBitmap();
		}
		if (!isAbout && !isHelp)
		{
			if (goto_status == 0)
			{
				choose.SetTopLeft(200, 300);
			}
			if (goto_status == 1)
			{
				choose.SetTopLeft(200, 352);
			}
			if (goto_status == 2)
			{
				choose.SetTopLeft(200, 396);
			}
			choose.ShowBitmap();
		}
		//
		// Demo螢幕字型的使用，不過開發時請盡量避免直接使用字型，改用CMovingBitmap比較好
		//
		CDC *pDC = CDDraw::GetBackCDC();			// 取得 Back Plain 的 CDC 
		CFont f, *fp;
		f.CreatePointFont(160, "Times New Roman");	// 產生 font f; 160表示16 point的字
		fp = pDC->SelectObject(&f);					// 選用 font f
		pDC->SetBkColor(RGB(0, 0, 0));
		pDC->SetTextColor(RGB(255, 255, 0));
		pDC->SelectObject(fp);						// 放掉 font f (千萬不要漏了放掉)
		CDDraw::ReleaseBackCDC();					// 放掉 Back Plain 的 CDC
	}
	/////////////////////////////////////////////////////////////////////////////
	// 這個class為遊戲的結束狀態(Game Over)
	/////////////////////////////////////////////////////////////////////////////
	CGameStateOver::CGameStateOver(CGame *g)
		: CGameState(g)
	{
	}
	void CGameStateOver::OnMove()
	{
		counter--;
		gameover.OnMove();
		if (counter < 0)
		{
			CAudio::Instance()->Stop(AUDIO_GOLDENWIND);
			GotoGameState(GAME_STATE_INIT);
		}
	}
	void CGameStateOver::OnBeginState()
	{
		counter = 30 * 3; // 4 seconds
		CAudio::Instance()->Play(AUDIO_GAMEOVER, false);
	}
	void CGameStateOver::OnInit()
	{
		//
		// 當圖很多時，OnInit載入所有的圖要花很多時間。為避免玩遊戲的人
		//     等的不耐煩，遊戲會出現「Loading ...」，顯示Loading的進度。
		//
		ShowInitProgress(66);	// 接個前一個狀態的進度，此處進度視為66%
		//
		// 開始載入資料
		//
		// 最終進度為100%
		//
		ShowInitProgress(100);
		char *filename_gameover[15] = { ".\\bitmaps\\GAME_OVER_0.bmp",".\\bitmaps\\GAME_OVER_1.bmp",".\\bitmaps\\GAME_OVER_2.bmp",".\\bitmaps\\GAME_OVER_3.bmp",".\\bitmaps\\GAME_OVER_4.bmp",".\\bitmaps\\GAME_OVER_5.bmp",".\\bitmaps\\GAME_OVER_6.bmp",".\\bitmaps\\GAME_OVER_7.bmp",".\\bitmaps\\GAME_OVER_8.bmp",".\\bitmaps\\GAME_OVER_9.bmp",".\\bitmaps\\GAME_OVER_10.bmp",".\\bitmaps\\GAME_OVER_11.bmp",".\\bitmaps\\GAME_OVER_12.bmp",".\\bitmaps\\GAME_OVER_13.bmp",".\\bitmaps\\GAME_OVER_14.bmp",};
		for (int i = 0; i < 15; i++)
			gameover.AddBitmap(filename_gameover[i], RGB(0, 0, 0));
		gameover.SetDelayCount(6);
		CAudio::Instance()->Load(AUDIO_GAMEOVER, "sounds\\gameover.mp3");
	}
	void CGameStateOver::OnShow()
	{
			gameover.SetTopLeft(0, 100);
			gameover.OnShow();
	}
	/////////////////////////////////////////////////////////////////////////////
	// 這個class為遊戲的遊戲執行物件，主要的遊戲程式都在這裡
	/////////////////////////////////////////////////////////////////////////////
	CGameStateRun::CGameStateRun(CGame *g)
		: CGameState(g), NUMBALLS(28)
	{
		current_stage = STAGE_1_1;
		enemys1_1.push_back(new Scarecrow(400, 450, &player1));
		enemys1_1.push_back(new Box(256, 384, &player1));
		enemys1_2.push_back(new RedGoblin(300, 450, &player1));
		enemys1_2.push_back(new RedGoblin(300, 550, &player1));
		for (int i = 0; i < 3; i++) {
			enemys1_1.push_back(new Box((64 * 3 * i) + 128, 448, &player1));
			enemys1_2.push_back(new Box((64 * 3*i)+128, 448, &player1));
			enemys1_4.push_back(new Box((64 * 3 * i) + 128, 448, &player1));
			enemys2_1.push_back(new Box((64 * 3 * i) + 128, 448, &player1));
			enemys2_2.push_back(new Box((64 * 3 * i) + 128, 448, &player1));
		}
		for (int i = 0; i < 2; i++) {
			enemys1_2.push_back(new RedSlime((64 * 3*i)+400, 448, &player1));
		}
		for (int i = 0; i < 2; i++) {
			enemys1_2.push_back(new GreenSlime((64 * 3 * i) + 300, 400, &player1));
		}
		for (int i = 0; i < 2; i++) {
			enemys1_2.push_back(new BlueSlime((64 * 3 * i) + 200, 496, &player1));
		}
		enemys1_3.push_back(new RedGoblin(300, 550, &player1));
		for (int i = 0; i < 5; i++) {
			enemys1_4.push_back(new GreenSlime(200, (300 + 64*i), &player1));
			enemys1_4.push_back(new RedSlime(900, (300 + 64 * i), &player1));
			enemys1_4.push_back(new BlueSlime( (200 + 64*i), 900, &player1));
			enemys1_4.push_back(new Scarecrow(500, (200 + 64*i), &player1));
		}
		enemys1_4.push_back(new ABoss(800, 300, &player1));
		enemys2_1.push_back(new RedSlime(600, 600, &player1));
		enemys2_4.push_back(new IceBird(600, 500, &player1));
		enemys2_4.push_back(new BlueSlime(500, 500, &player1));
	}
	CGameStateRun::~CGameStateRun()
	{
		for (vector<Enemy*>::iterator it_i = enemys1_1.begin(); it_i != enemys1_1.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys1_2.begin(); it_i != enemys1_2.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys1_3.begin(); it_i != enemys1_3.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys1_4.begin(); it_i != enemys1_4.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys2_1.begin(); it_i != enemys2_1.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys2_2.begin(); it_i != enemys2_2.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys2_3.begin(); it_i != enemys2_3.end(); ++it_i) {
			delete *it_i;
		}
		for (vector<Enemy*>::iterator it_i = enemys2_4.begin(); it_i != enemys2_4.end(); ++it_i) {
			delete *it_i;
		}
	}
	void CGameStateRun::OnBeginState()
	{
		const int BALL_GAP = 90;
		const int BALL_XY_OFFSET = 45;
		const int BALL_PER_ROW = 7;
		const int HITS_LEFT = 10;
		const int HITS_LEFT_X = 590;
		const int HITS_LEFT_Y = 0;
		const int BACKGROUND_X = 60;
		const int ANIMATION_SPEED = 15;
		isAllLevelPass = all_level_pass_count = 0;
		CAudio::Instance()->Play(AUDIO_GOLDENWIND, true);			// 撥放 MIDI
		player1.Initialize();
		//第一關怪物
		for (unsigned i = 0; i < enemys1_1.size(); i++) 
		{
			enemys1_1[i]->Initialize();
		}
		//第二關怪物
		for (unsigned i = 0; i < enemys1_2.size(); i++)
		{
			enemys1_2[i]->Initialize();
		}
		//1_3怪物
		for (unsigned i = 0; i < enemys1_3.size(); i++)
		{
			enemys1_3[i]->Initialize();
		}
		//第六關怪物
		for (unsigned i = 0; i < enemys1_4.size(); i++) 
		{
			enemys1_4[i]->Initialize();
		}
		//2_1怪物
		for (unsigned i = 0; i < enemys2_1.size(); i++)
		{
			enemys2_1[i]->Initialize();
		}
		//2_2怪物
		for (unsigned i = 0; i < enemys2_2.size(); i++)
		{
			enemys2_2[i]->Initialize();
		}
		//2_3怪物
		for (unsigned i = 0; i < enemys2_3.size(); i++) 
		{
			enemys2_3[i]->Initialize();
		}
		//2_4怪物
		for (unsigned i = 0; i < enemys2_4.size(); i++)
		{
			enemys2_4[i]->Initialize();
		}
		current_stage = STAGE_1_1;
		map_stg1_1.Initialize();
		map_stg1_4.Initialize();
		map_stg1_2.Initialize();
		map_stg1_3.Initialize();
		map_stg2_1.Initialize();
		map_stg2_2.Initialize();
		map_stg2_3.Initialize();
		map_stg2_4.Initialize();
		player_status.Initialize(&player1);
	}
	void CGameStateRun::stage_process_move(Maps & stage_map, Hero & player, vector<Enemy*> & enemy_array, STAGE next_stage)
	{
		//王關會有不一樣的音樂
		if ((current_stage == STAGE_1_4 || current_stage == STAGE_2_4) && change_song)
		{
			CAudio::Instance()->Stop(AUDIO_GOLDENWIND);			// 撥放 MIDI
			CAudio::Instance()->Play(AUDIO_AWAKEN, true);			// 撥放 MIDI
			change_song = 0;
		}
		if (!(current_stage == STAGE_1_4 || current_stage == STAGE_2_4) && change_song )
		{
			CAudio::Instance()->Stop(AUDIO_AWAKEN);			// 撥放 MIDI
			CAudio::Instance()->Play(AUDIO_GOLDENWIND);			// 撥放 MIDI
			change_song = 0;
		}
		player.OnMove(&stage_map, &enemy_array);
		for (unsigned i = 0; i < enemy_array.size(); i++)
		{
			enemy_array[i]->OnMove(&stage_map);
		}
		sort(enemy_array.begin(), enemy_array.end(), [](Enemy *a, Enemy *b) {return a->GetY2() < b->GetY2(); });
		int next_x, next_y = 0;
		switch (next_stage)
		{
		case STAGE_1_2: next_x = 480; next_y = 480;
			break;
		case STAGE_1_3: next_x = 480; next_y = 480;
			break;
		case STAGE_1_4: next_x = 780; next_y = 1470;
			break;
		case STAGE_2_1: next_x = 480; next_y = 480;
			break;
		case STAGE_2_2: next_x = 480; next_y = 480;
			break;
		case STAGE_2_3: next_x = 480; next_y = 480;
			break;
		case STAGE_2_4: next_x = 480; next_y = 480;
			break;
		}
		stage_map.setClear(allEnemyDie(enemy_array));
		int random_scold = rand() % 100;
		//如果打所有怪物打死且主角進入下一關的區域
		if (allEnemyDie(enemy_array) && player.isInFinishArea(&stage_map))
		{
			//怪物被主角消滅，主角覺得怪物太爛了於是大罵一聲，爛!
			if (random_scold <= 40)
				CAudio::Instance()->Play(AUDIO_SCOLD, false);
			//若通關播放通關畫面6秒
			if (next_stage == CONGRATULATION)
			{
				all_level_pass_count = 180;
				isAllLevelPass = 1;
			}
			if (current_stage == STAGE_1_3 || current_stage == STAGE_2_3 || current_stage == STAGE_1_4)
				change_song = 1;
			current_stage = next_stage;
			player.SetXY(next_x, next_y);
		}
	}

	void CGameStateRun::OnMove()							// 移動遊戲元素
	{
		switch (current_stage)
		{
			case STAGE_1_1:
				stage_process_move(map_stg1_1, player1, enemys1_1, STAGE_1_2);
				break;
			case STAGE_1_2:
				stage_process_move(map_stg1_2, player1, enemys1_2, STAGE_1_3);
				break;
			case STAGE_1_3:
				stage_process_move(map_stg1_3, player1, enemys1_3, STAGE_1_4);
				break;
			case STAGE_1_4:
				stage_process_move(map_stg1_4, player1, enemys1_4, STAGE_2_1);
				break;
			case STAGE_2_1:
				stage_process_move(map_stg2_1, player1, enemys2_1, STAGE_2_2);
				break;
			case STAGE_2_2:
				stage_process_move(map_stg2_2, player1, enemys2_2, STAGE_2_3);
				break;
			case STAGE_2_3:
				stage_process_move(map_stg2_3, player1, enemys2_3, STAGE_2_4);
				break;
			case STAGE_2_4:
				stage_process_move(map_stg2_4, player1, enemys2_4, CONGRATULATION);
				break;
		}
		//如果主角死了
		if (!player1.isAlive()) 
		{
			GotoGameState(GAME_STATE_OVER);
			for (int i = 0; i < 6; i++)
			{
				player1.useItem(i + 1);
			}
		}
		if (isAllLevelPass && all_level_pass_count>= 0)
		{
			all_level_pass_count -= 1;
			CAudio::Instance()->Play(AUDIO_ICEBIRD_DIE, false);
		}
		if (isAllLevelPass && all_level_pass_count <= 0)
		{
			for (int i = 0; i < 6; i++)
			{
				player1.useItem(i + 1);
			}
			GotoGameState(GAME_STATE_INIT);
		}
		if (background.Top() > SIZE_Y)
			background.SetTopLeft(60, -background.Height());
		background.SetTopLeft(background.Left(), background.Top() + 1);
	}
	void CGameStateRun::OnInit()  								// 遊戲的初值及圖形設定
	{
		//
		// 當圖很多時，OnInit載入所有的圖要花很多時間。為避免玩遊戲的人
		//     等的不耐煩，遊戲會出現「Loading ...」，顯示Loading的進度。
		//
		ShowInitProgress(33);	// 接個前一個狀態的進度，此處進度視為33%
		//
		// 開始載入資料
		//
		player1.LoadBitmap();
		player_status.loadPlayerStatus();
		change_song = 0;
		//1-1怪物
		for (unsigned i = 0; i < enemys1_1.size(); i++) 
		{
			enemys1_1[i]->LoadBitmap();
		}
		//1-2怪物
		for (unsigned i = 0; i < enemys1_2.size(); i++)
		{
			enemys1_2[i]->LoadBitmap();
		}
		//1_3怪物
		for (unsigned i = 0; i < enemys1_3.size(); i++)
		{
			enemys1_3[i]->LoadBitmap();
		}
		//1-4怪物
		for (unsigned i = 0; i < enemys1_4.size(); i++)
		{
			enemys1_4[i]->LoadBitmap();
		}
		//2_1怪物
		for (unsigned i = 0; i < enemys2_1.size(); i++)
		{
			enemys2_1[i]->LoadBitmap();
		}
		//2_2怪物
		for (unsigned i = 0; i < enemys2_2.size(); i++)
		{
			enemys2_2[i]->LoadBitmap();
		}
		//2_3怪物
		for (unsigned i = 0; i < enemys2_3.size(); i++)
		{
			enemys2_3[i]->LoadBitmap();
		}
		//2_4怪物
		for (unsigned i = 0; i < enemys2_4.size(); i++) 
		{
			enemys2_4[i]->LoadBitmap();
		}
		background.LoadBitmap(IDB_BACKGROUND);					// 載入背景的圖形
		map_stg1_1.LoadBitmap();
		map_stg1_2.LoadBitmap();
		map_stg1_3.LoadBitmap();
		map_stg1_4.LoadBitmap();
		map_stg2_1.LoadBitmap();
		map_stg2_2.LoadBitmap();
		map_stg2_3.LoadBitmap();
		map_stg2_4.LoadBitmap();
		//
		// 完成部分Loading動作，提高進度
		//
		ShowInitProgress(50);
		//
		// 繼續載入其他資料
		//
		help.LoadBitmap(IDB_HELP, RGB(255, 255, 255));				// 載入說明的圖形
		you_win.LoadBitmap(".\\RES\\You_win.bmp");
		corner.LoadBitmap(IDB_CORNER);							// 載入角落圖形
		corner.ShowBitmap(background);							// 將corner貼到background
		hits_left.LoadBitmap();
		CAudio::Instance()->Load(AUDIO_GOLDENWIND, "sounds\\goldenwind.mp3");	// 載入編號2的聲音ntut.mid
		CAudio::Instance()->Load(AUDIO_SWORD, "sounds\\swing2.mp3");
		CAudio::Instance()->Load(AUDIO_FIRE, "sounds\\fireball.mp3");
		CAudio::Instance()->Load(AUDIO_SKILLE, "sounds\\swing4.mp3");
		CAudio::Instance()->Load(AUDIO_SKILLR_1, "sounds\\skillR_1.mp3");
		CAudio::Instance()->Load(AUDIO_SKILLR_2, "sounds\\skillR_2.mp3");
		CAudio::Instance()->Load(Audio_KNIFE,  "sounds\\knife2.mp3");
		CAudio::Instance()->Load(AUDIO_ICE, "sounds\\iceball.mp3");
		CAudio::Instance()->Load(AUDIO_HITTING, "sounds\\hitting4.mp3");
		CAudio::Instance()->Load(AUDIO_GRASSBALL, "sounds\\grassball.mp3");
		CAudio::Instance()->Load(AUDIO_BEGGER, "sounds\\begger.mp3");
		CAudio::Instance()->Load(AUDIO_AWAKEN, "sounds\\awaken.mp3");
		CAudio::Instance()->Load(AUDIO_DAMAGE1, "sounds\\damage1.mp3");
		CAudio::Instance()->Load(AUDIO_ABOSS_WALK, "sounds\\footsteps_of_a_giant.mp3");
		CAudio::Instance()->Load(AUDIO_ABOSS_PREPARE, "sounds\\ABoss_prepare.mp3");
		CAudio::Instance()->Load(AUDIO_GOODFLASH, "sounds\\goodflash.mp3");
		CAudio::Instance()->Load(AUDIO_BADFLASH, "sounds\\badflash.mp3");
		CAudio::Instance()->Load(AUDIO_ICEBIRD_DIE, "sounds\\icebirddie.mp3");
		CAudio::Instance()->Load(AUDIO_BEING_ATTACKED, "sounds\\being_attacked.mp3");
		CAudio::Instance()->Load(AUDIO_SCOLD, "sounds\\scold.mp3");
		CAudio::Instance()->Load(AUDIO_SHOE, "sounds\\shoe.mp3");
		CAudio::Instance()->Load(AUDIO_SING, "sounds\\sing.mp3");
		//
		// 此OnInit動作會接到CGameStaterOver::OnInit()，所以進度還沒到100%
		//
	}

	void CGameStateRun::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
	{
		int n = rand() % 3;
		switch (nChar)
		{
		case KEY_LEFT: player1.SetMovingLeft(true); break;
		case KEY_RIGHT: player1.SetMovingRight(true); break;
		case KEY_UP: player1.SetMovingUp(true); break;
		case KEY_DOWN: player1.SetMovingDown(true); break;
		case NUM_0:
			if(n == 0)
				player1.SetElementAttribute(FIRE);
			if (n == 1)
				player1.SetElementAttribute(ICE);
			if (n == 2)
				player1.SetElementAttribute(PLANT);
			break;
		case NUM_1: player1.useItem(1); break;
		case NUM_2: player1.useItem(2); break;
		case NUM_3: player1.useItem(3); break;
		case NUM_4: player1.useItem(4); break;
		case NUM_5: player1.useItem(5); break;
		case NUM_6: player1.useItem(6); break;
		case NUM_9: 
			player1.addHp(50);
			player1.addAttack(5, FIRE);
			player1.addAttack(5, PLANT);
			player1.addAttack(5, ICE);
			break; 
		case KEY_A: player1.SetUsingA(true); break;
		case KEY_Q: player1.SetUsingQ(true); break;
		case KEY_W: 
			player1.setShadePosition();
			player1.SetUsingW(true); break;
		case KEY_E: player1.SetUsingE(true); break;
		case KEY_R: player1.SetUsingR(true); break;
		case J_STG1_1: current_stage = STAGE_1_1; player1.SetXY(480, 480); map_stg1_1.Initialize(); change_song = 1; break;	//z
		case J_STG1_2: current_stage = STAGE_1_2; player1.SetXY(480, 480); map_stg1_2.Initialize(); change_song = 1; break;	//x
		case J_STG1_4: current_stage = STAGE_1_3; player1.SetXY(480, 480); map_stg1_3.Initialize(); change_song = 1; break;	//c
		case J_STG1_6: current_stage = STAGE_1_4; player1.SetXY(780, 1470); map_stg1_4.Initialize(); change_song = 1; break;	//v
		case J_STG2_1: current_stage = STAGE_2_1; player1.SetXY(480, 480); map_stg2_1.Initialize(); change_song = 1; break;	//b
		case J_STG2_2: current_stage = STAGE_2_2; player1.SetXY(480, 480); map_stg2_2.Initialize(); change_song = 1; break;	//n
		case J_STG2_3: current_stage = STAGE_2_3; player1.SetXY(480, 480); map_stg2_3.Initialize(); change_song = 1; break;	//m
		case J_STG2_4: current_stage = STAGE_2_4; player1.SetXY(480, 480); map_stg2_4.Initialize(); change_song = 1; break;	//j

		default: return;
		}
	}
	void CGameStateRun::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
	{
		switch (nChar)
		{
		case KEY_LEFT: player1.SetMovingLeft(false); break;
		case KEY_RIGHT: player1.SetMovingRight(false); break;
		case KEY_UP: player1.SetMovingUp(false); break;
		case KEY_DOWN: player1.SetMovingDown(false); break;
		case 27:GotoGameState(GAME_STATE_INIT); for (int i = 0; i < 6; i++)
		{
			player1.useItem(i + 1);
		}
				GotoGameState(GAME_STATE_INIT); break;
		default: return;
		}
	}
	void CGameStateRun::OnLButtonDown(UINT nFlags, CPoint point)  // 處理滑鼠的動作
	{
	}
	void CGameStateRun::OnLButtonUp(UINT nFlags, CPoint point)	// 處理滑鼠的動作
	{
	}
	void CGameStateRun::OnMouseMove(UINT nFlags, CPoint point)	// 處理滑鼠的動作
	{
	}
	void CGameStateRun::OnRButtonDown(UINT nFlags, CPoint point)  // 處理滑鼠的動作
	{
	}
	void CGameStateRun::OnRButtonUp(UINT nFlags, CPoint point)	// 處理滑鼠的動作
	{
	}
	bool CGameStateRun::allEnemyDie(vector<Enemy*> enemys)
	{
		for (unsigned i = 0; i < enemys.size(); i++)
		{
			if (enemys.at(i)->isAlive() && enemys.at(i)->GetName() != "Box") 
			{
				return false;
			}
		}
		return true;
	}
	void CGameStateRun::OnShow()
	{
		//
		//  注意：Show裡面千萬不要移動任何物件的座標，移動座標的工作應由Move做才對，
		//        否則當視窗重新繪圖時(OnDraw)，物件就會移動，看起來會很怪。換個術語
		//        說，Move負責MVC中的Model，Show負責View，而View不應更動Model。
		corner.SetTopLeft(0, 0);
		corner.SetTopLeft(SIZE_X - corner.Width(), SIZE_Y - corner.Height());
		/////////////////////////////////////////////1-1
		if (current_stage == STAGE_1_1) 
		{
			map_stg1_1.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys1_1.size(); i++) 
			{
				if (player1.GetY2() > enemys1_1[i]->GetY2()) 
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1) 
			{
				player1.OnShow(&map_stg1_1);
			}
			for (unsigned i = 0; i < enemys1_1.size(); i++) 
			{
				enemys1_1[i]->OnShow(&map_stg1_1);
				if (i == hero_position)
				{							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg1_1);
				}
			}
		}
		/////////////////////////////////////////////1-2
		if (current_stage == STAGE_1_2)
		{
			map_stg1_2.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys1_2.size(); i++)
			{
				if (player1.GetY2() > enemys1_2[i]->GetY2()) 
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1)
			{
				player1.OnShow(&map_stg1_2);
			}
			for (unsigned i = 0; i < enemys1_2.size(); i++)
			{
				enemys1_2[i]->OnShow(&map_stg1_2);
				if (i == hero_position)
				{							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg1_2);
				}
			}
		}
		/////////////////////////////////////////////1-3
		if (current_stage == STAGE_1_3)
		{
			map_stg1_3.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys1_3.size(); i++) 
			{
				if (player1.GetY2() > enemys1_3[i]->GetY2()) 
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1)
			{
				player1.OnShow(&map_stg1_3);
			}
			for (unsigned i = 0; i < enemys1_3.size(); i++)
			{
				enemys1_3[i]->OnShow(&map_stg1_3);
				if (i == hero_position) 
				{							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg1_3);
				}
			}
		}
		/////////////////////////////////////////////1-4
		if (current_stage == STAGE_1_4)
		{
			map_stg1_4.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys1_4.size(); i++) 
			{
				if (player1.GetY2() > enemys1_4[i]->GetY2()) 
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1) 
			{
				player1.OnShow(&map_stg1_4);
			}
			for (unsigned i = 0; i < enemys1_4.size(); i++) 
			{
				enemys1_4[i]->OnShow(&map_stg1_4);
				if (i == hero_position)
				{							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg1_4);
				}
			}
		}
		/////////////////////////////////////////////2-1
		if (current_stage == STAGE_2_1) 
		{
			map_stg2_1.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys2_1.size(); i++) 
			{
				if (player1.GetY2() > enemys2_1[i]->GetY2())
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1)
			{
				player1.OnShow(&map_stg2_1);
			}
			for (unsigned i = 0; i < enemys2_1.size(); i++)
			{
				enemys2_1[i]->OnShow(&map_stg2_1);
				if (i == hero_position)
				{							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg2_1);
				}
			}
		}
		/////////////////////////////////////////////2_2
		if (current_stage == STAGE_2_2)
		{
			map_stg2_2.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys2_2.size(); i++)
			{
				if (player1.GetY2() > enemys2_2[i]->GetY2())
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1)
			{
				player1.OnShow(&map_stg2_2);
			}
			for (unsigned i = 0; i < enemys2_2.size(); i++) 
			{
				enemys2_2[i]->OnShow(&map_stg2_2);
				if (i == hero_position) 
				{							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg2_2);
				}
			}
		}
		/////////////////////////////////////////////2_3
		if (current_stage == STAGE_2_3) 
		{
			map_stg2_3.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys2_3.size(); i++) 
			{
				if (player1.GetY2() > enemys2_3[i]->GetY2())
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1)
			{
				player1.OnShow(&map_stg2_3);
			}
			for (unsigned i = 0; i < enemys2_3.size(); i++)
			{
				enemys2_3[i]->OnShow(&map_stg2_3);
				if (i == hero_position) {							//如果show到剛剛比較到的位置，show hero
					player1.OnShow(&map_stg2_3);
				}
			}
		}
		/////////////////////////////////////////////2_4
		if (current_stage == STAGE_2_4)
		{
			map_stg2_4.OnShow();
			int hero_position = -1;									//如果Hero的座標比最上面的敵人更上面 position = -1					
			for (unsigned i = 0; i < enemys2_4.size(); i++) 
			{
				if (player1.GetY2() > enemys2_4[i]->GetY2())
				{		//逐一比較Y座標，找到Hero的位置在哪兩個怪物中間
					hero_position = i;
				}
			}
			if (hero_position == -1) 
			{
				player1.OnShow(&map_stg2_4);
			}
			for (unsigned i = 0; i < enemys2_4.size(); i++) 
			{
				enemys2_4[i]->OnShow(&map_stg2_4);
			}
			player1.OnShow(&map_stg2_4);
		}
		if (isAllLevelPass && all_level_pass_count >= 0)
		{
			you_win.SetTopLeft(0, 0);
			you_win.ShowBitmap();
		}
		player_status.showPlayerStatus();
	}
};



mygame.h
#include "ABoss.h"
#include "Maps.h"
#include "Map1_1.h"
#include "Map1_2.h"
#include "Map1_3.h"
#include "Map1_4.h"
#include "Map2_1.h"
#include "Map2_2.h"
#include "Map2_3.h"
#include "Map2_4.h"
#include "Hero.h"
#include "Enemy.h"
#include "Util.h"
#include "Character.h"
#include "Scarecrow.h"
#include "GreenSlime.h"
#include "RedSlime.h"
#include "BlueSlime.h"
#include "RedGoblin.h"
#include "BlueGoblin.h"
#include "GreenGoblin.h"
#include "Box.h"
#include "PlayerStatus.h"

namespace game_framework 
{
	/////////////////////////////////////////////////////////////////////////////
	// mygame.h: 本檔案儲遊戲本身的class的interface							   //
	/////////////////////////////////////////////////////////////////////////////
	class CGameStateInit : public CGameState
	{
	public:
		CGameStateInit(CGame *g);
		void OnInit();  								// 遊戲的初值及圖形設定
		void OnBeginState();							// 設定每次重玩所需的變數
		void OnKeyUp(UINT, UINT, UINT); 				// 處理鍵盤Up的動作
		void OnLButtonDown(UINT nFlags, CPoint point);  // 處理滑鼠的動作
	protected:
		void OnShow();									// 顯示這個狀態的遊戲畫面
	private:
		CMovingBitmap logo;								// csie的logo
		CMovingBitmap selection;
		CMovingBitmap help;
		CMovingBitmap about;
		CMovingBitmap choose;
		int goto_status;								// 0是上面的 game start, 1是下面的 story
		bool isHelp;
		bool isAbout;
	};
	/////////////////////////////////////////////////////////////////////////////
	// 這個class為遊戲的遊戲執行物件，主要的遊戲程式都在這裡
	/////////////////////////////////////////////////////////////////////////////
	class CGameStateRun : public CGameState 
	{
	public:
		CGameStateRun(CGame *g);
		~CGameStateRun();
		void OnBeginState();							// 設定每次重玩所需的變數
		void stage_process_move(Maps & stage_map, Hero & player, vector<Enemy*>& enemy_array, STAGE next_stage);
		void OnInit();  								// 遊戲的初值及圖形設定
		void OnKeyDown(UINT, UINT, UINT);
		void OnKeyUp(UINT, UINT, UINT);
		void OnLButtonDown(UINT nFlags, CPoint point);  // 處理滑鼠的動作
		void OnLButtonUp(UINT nFlags, CPoint point);	// 處理滑鼠的動作
		void OnMouseMove(UINT nFlags, CPoint point);	// 處理滑鼠的動作 
		void OnRButtonDown(UINT nFlags, CPoint point);  // 處理滑鼠的動作
		void OnRButtonUp(UINT nFlags, CPoint point);	// 處理滑鼠的動作
		bool allEnemyDie(vector<Enemy*> enemys);
	protected:
		void OnMove();									// 移動遊戲元素
		void OnShow();									// 顯示這個狀態的遊戲畫面
	private:
		const int		NUMBALLS;	// 球的總數
		PlayerStatus	player_status;
		Map1_1			map_stg1_1;
		Map1_2			map_stg1_2;
		Map1_3			map_stg1_3;
		Map1_4			map_stg1_4;
		Map2_1			map_stg2_1;
		Map2_2			map_stg2_2;
		Map2_3			map_stg2_3;
		Map2_4			map_stg2_4;
		Hero			player1;
		vector<Enemy*>  enemys1_1;
		vector<Enemy*>  enemys1_2;
		vector<Enemy*>  enemys1_3;
		vector<Enemy*>  enemys1_4;
		vector<Enemy*>  enemys2_1;
		vector<Enemy*>  enemys2_2;
		vector<Enemy*>  enemys2_3;
		vector<Enemy*>  enemys2_4;
		STAGE			current_stage;
		CMovingBitmap	background;	// 背景圖
		CMovingBitmap	help;		// 說明圖
		CMovingBitmap	corner;		// 角落圖
		CMovingBitmap you_win;
		CInteger		hits_left;	// 剩下的撞擊數
		bool isAllLevelPass;
		int all_level_pass_count;
		int change_song;
	};
	/////////////////////////////////////////////////////////////////////////////
	// 這個class為遊戲的結束狀態(Game Over)
	/////////////////////////////////////////////////////////////////////////////
	class CGameStateOver : public CGameState
	{
	public:
		CGameStateOver(CGame *g);
		void OnBeginState();							// 設定每次重玩所需的變數
		void OnInit();
	protected:
		void OnMove();									// 移動遊戲元素
		void OnShow();									// 顯示這個狀態的遊戲畫面
	private:
		int counter;	// 倒數之計數器
		CAnimation gameover;
	};
}
